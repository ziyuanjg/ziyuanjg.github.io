<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[AVL树的平衡算法（JAVA实现）]]></title>
      <url>/2017/06/19/AVL/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>　　AVL树本质上还是一个二叉搜索树，不过比二叉搜索树多了一个平衡条件：每个节点的左右子树的高度差不大于1。二叉树的应用是为了弥补链表的查询效率问题，但是极端情况下，二叉搜索树会无限接近于链表，这种时候就无法体现二叉搜索树在查询时的高效率，而最初出现的解决方式就是AVL树。如下图：<br><a id="more"></a><br><img src="/images/mybatis_30.png" alt=""></p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>　　说到AVL树就不得不提到树的旋转，旋转是AVL维持平衡的方式，主要有以下四种类型。</p>
<h3 id="左左旋转"><a href="#左左旋转" class="headerlink" title="左左旋转"></a>左左旋转</h3><p>　　如图2-1所示，此时A节点的左树与右树的高度差为2，不符合AVL的定义，此时以B节点为轴心，AB间连线为转轴，将A节点旋转至B节点下方，由B节点的父节点变成子节点。实现所有节点的左右子树高度差小于等于1。如图2-2。<br><img src="/images/mybatis_31.png" alt=""></p>
<h3 id="右右旋转"><a href="#右右旋转" class="headerlink" title="右右旋转"></a>右右旋转</h3><p>　　右右旋转与左左旋转类似，但是动作相反，如图2-3，2-4所示，以B节点为轴心，BC间连线为轴，将C节点旋转至B下方，成为B的子节点。实现所有节点的左右子树高度差小于等于1。<br><img src="/images/mybatis_32.png" alt=""></p>
<h3 id="左右旋转"><a href="#左右旋转" class="headerlink" title="左右旋转"></a>左右旋转</h3><p>　　左右旋转稍复杂一点，需要旋转两次，如果用左左旋转的方式直接旋转图2-5中的树，会变成图2-8的样子，此时B节点的左右子树高度差依然没有平衡，所以要先对2-5的树做一步处理，就是以BC为轴，将C节点旋转至B节点的位置，如图2-6所示，此时就将树转换成了左左旋转的场景，之后使用左左旋转即可完成平衡。<br><img src="/images/mybatis_33.png" alt=""></p>
<h3 id="右左旋转"><a href="#右左旋转" class="headerlink" title="右左旋转"></a>右左旋转</h3><p>　　右左旋转与左右旋转类似，也是旋转两次。如下图，具体细节请看下面的代码详解。<br><img src="/images/mybatis_34.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>　　二叉树的插入不在赘述，这里只分析插入时的平衡方法。如果新增节点没有兄弟节点时会引起树的高度变化，此时需要对上层节点的平衡值进行修改，如果出现了不平衡树，则需要调用平衡方法，代码如下：</p>
<pre><code>private void balance(Node node){
    Node parent = node.getParent();
    Node node_middle = node;
    Node node_prev = node;

    Boolean avl = true;
    do{
        if(node_middle == parent.getLeft() &amp;&amp; (-1 &lt;= parent.getAVL()-1 &amp;&amp; parent.getAVL()-1 &lt;= 1)){
            //node_middle为parent的左树，此时parent左树高度+1不会造成不平衡。
            parent.subAVL();
            node_prev = node_middle;
            node_middle = parent;
            //由于上面对parent的平衡值进行了修改，如果修改后的平衡值为0，说明此时parent节点的高度没有改变，之前较短的左树高度+1，变为与右树高度相同。
            if(parent != null &amp;&amp; parent.getAVL() == 0)
                parent = null;
            else
                parent = parent.getParent();
        }else if(node_middle == parent.getRight() &amp;&amp; (-1 &lt;= parent.getAVL()+1 &amp;&amp; parent.getAVL()+1 &lt;= 1)){
            //node_middle为parent的右树，此时parent右树高度+1不会造成不平衡。
            parent.addAVL();
            node_prev = node_middle;
            node_middle = parent;
            //由于上面对parent的平衡值进行了修改，如果修改后的平衡值为0，说明此时parent节点的高度没有改变，之前较短的右树高度+1，变为与左树高度相同。
            if(parent != null &amp;&amp; parent.getAVL() == 0)
                parent = null;
            else
                parent = parent.getParent();
        }else{//出现最小不平衡节点，新增时不需要考虑更高节点，所以直接中断循环，调用平衡方法
            avl = false;
        }
    }while(parent != null &amp;&amp; avl);

    if(parent == null){
        return;
    }
    //选择相应的旋转方式
    chooseCalculation(parent, node_middle, node_prev);
}
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>　　删除较新增复杂一些，主要是因为存在一次旋转无法达到平衡效果的情况，而且删除本身也分为三种情况，分别是：</p>
<h4 id="删除叶子节点"><a href="#删除叶子节点" class="headerlink" title="删除叶子节点"></a>删除叶子节点</h4><p>　　由于叶子节点没有子树，不涉及替换的问题，所以直接删除即可，如果删除节点没有兄弟节点会引起高度变化，此时依次对父级节点的平衡值做对应修改，如果出现不平衡树则要进行旋转。</p>
<h4 id="删除节点存在一个子节点"><a href="#删除节点存在一个子节点" class="headerlink" title="删除节点存在一个子节点"></a>删除节点存在一个子节点</h4><p>　　此时将子节点上移，替换删除节点的位置，这个操作势必会造成所在子树的高度变化，所以需要依次对父级节点的平衡值做对应修该，如果出现不平衡树进行旋转操作。</p>
<h4 id="删除节点存在两个子节点"><a href="#删除节点存在两个子节点" class="headerlink" title="删除节点存在两个子节点"></a>删除节点存在两个子节点</h4><p>　　这种情况比较复杂，由于存在两个子节点，所以不能简单的将其中一个子节点提高一级，因此需要在节点的子树中搜索一个合适的节点进行替换，之前自己构思的时候选择的是搜寻一个最长子树的最接近删除节点的值的叶子节点，具体实现的时候发现需要考虑的场景太多，并不适合，参考算法导论上的思路后改成了搜寻左树的最大节点，此时只需考虑左树的情况即可。实现方法如下：</p>
<pre><code>public void deleteNode(int item){

    Node node = get(item);
    if(node == null)
        return;
    Node parent = node.getParent();
    if(!node.hasChild()){                                                //叶子节点
        if(parent == null){                                                //删除最后节点
            root = null;
            return;
        }
        if(node.hasBrother()){                                            //node有兄弟节点时，需要判断是否需要调用平衡方法
            if(node == parent.getLeft())
                isBalance(node, 1);
            else
                isBalance(node, -1);
            parent.deleteChildNode(node);
        }else{                                                            //node没有兄弟节点时，高度减一，需要进行平衡
            deleteAvl(node);
            parent.deleteChildNode(node);
        }
    }else if(node.getLeft() != null &amp;&amp; node.getRight() == null){        //有一个子节点时，将子节点上移一位，然后进行平衡即可
        if(parent == null){                                                //删除的是根节点
            root = node;
            return;
        }
        if(node == parent.getLeft()){
            parent.setLeft(node.getLeft());
        }else{
            parent.setRight(node.getLeft());
        }
        node.getLeft().setParent(parent);
        deleteAvl(node.getLeft());
    }else if(node.getLeft() == null &amp;&amp; node.getRight() != null){        //有一个子节点时，将子节点上移一位，然后进行平衡即可
        if(parent == null){                                                //删除的是根节点
            root = node;
            return;
        }
        if(node == parent.getRight()){
            parent.setRight(node.getRight());
        }else{
            parent.setLeft(node.getRight());
        }
        node.getRight().setParent(parent);
        deleteAvl(node.getRight());
    }
    else{                                                                //有两个子节点时，先在节点左树寻找最大节点last，然后删除last，最后将被删除节点的value替换为last的value
        Node last = findLastNode(node);
        int tmp = last.getValue();
        deleteNode(last.getValue());
        node.setValue(tmp);
    }
    node = null;                                                        //GC
}
</code></pre><h3 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h3><h4 id="左左旋转-1"><a href="#左左旋转-1" class="headerlink" title="左左旋转"></a>左左旋转</h4><pre><code>private void LeftLeftRotate(Node node){

    Node parent = node.getParent();

    if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getLeft()){
        node.setParent(parent.getParent());
        parent.getParent().setLeft(node);
    }else if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getRight()){
        node.setParent(parent.getParent());
        parent.getParent().setRight(node);
    }else{
        root = node;
        node.setParent(null);
    }
    parent.setParent(node);
    parent.setLeft(node.getRight());
    if(node.getRight() != null)
        node.getRight().setParent(parent);
    node.setRight(parent);

    if(node.getAVL() == -1){                                        //只有左节点时，parent转换后没有子节点
        parent.setAVL(0);
        node.setAVL(0);
    }else if(node.getAVL() == 0){                                    //node有两个子节点，转换后parent有一个左节点
        parent.setAVL(-1);
        node.setAVL(1);
    }                                                                //node.getAVL()为1时会调用左右旋转
}
</code></pre><h4 id="右右旋转-1"><a href="#右右旋转-1" class="headerlink" title="右右旋转"></a>右右旋转</h4><pre><code>private void RightRightRotate(Node node){

    Node parent = node.getParent();

    if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getLeft()){
        node.setParent(parent.getParent());
        parent.getParent().setLeft(node);
    }else if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getRight()){
        node.setParent(parent.getParent());
        parent.getParent().setRight(node);
    }else{
        root = node;
        node.setParent(null);
    }
    parent.setParent(node);
    parent.setRight(node.getLeft());
    if(node.getLeft() != null)
        node.getLeft().setParent(parent);
    node.setLeft(parent);

    if(node.getAVL() == 1){
        node.setAVL(0);
        parent.setAVL(0);
    }else if(node.getAVL() == 0){                                    //当node有两个节点时，转换后层数不会更改，左树比右树高1层，parent的右树比左树高一层
        parent.setAVL(1);
        node.setAVL(-1);
    }
}
</code></pre><h4 id="左右旋转-1"><a href="#左右旋转-1" class="headerlink" title="左右旋转"></a>左右旋转</h4><pre><code>private void LeftRightRotate(Node node){

    Node parent = node.getParent();
    Node child = node.getRight();

    //左右旋转时node的avl必为1，所以只需考虑child的avl
    if(!child.hasChild()){
        node.setAVL(0);
        parent.setAVL(0);
    }else if(child.getAVL() == -1){
        node.setAVL(0);
        parent.setAVL(1);
    }else if(child.getAVL() == 1){
        node.setAVL(-1);
        parent.setAVL(0);
    }else if(child.getAVL() == 0){
        node.setAVL(0);
        parent.setAVL(0);
    }
    child.setAVL(0);

    //第一次交换
    parent.setLeft(child);
    node.setParent(child);
    node.setRight(child.getLeft());
    if(child.getLeft() != null)
        child.getLeft().setParent(node);
    child.setLeft(node);
    child.setParent(parent);

    //第二次交换
    if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getLeft()){
        child.setParent(parent.getParent());
        parent.getParent().setLeft(child);
    }else if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getRight()){
        child.setParent(parent.getParent());
        parent.getParent().setRight(child);
    }else{
        root = child;
        child.setParent(null);
    }
    parent.setParent(child);
    parent.setLeft(child.getRight());
    if(child.getRight() != null)
        child.getRight().setParent(parent);
    child.setRight(parent);
}
</code></pre><h4 id="右左旋转-1"><a href="#右左旋转-1" class="headerlink" title="右左旋转"></a>右左旋转</h4><pre><code>private void RightLeftRotate(Node node){

    Node parent = node.getParent();
    Node child = node.getLeft();

    if(!child.hasChild()){
        node.setAVL(0);
        parent.setAVL(0);
    }else if(child.getAVL() == -1){
        node.setAVL(1);
        parent.setAVL(0);
    }else if(child.getAVL() == 1){
        node.setAVL(0);
        parent.setAVL(-1);
    }else if(child.getAVL() == 0){
        parent.setAVL(0);
        node.setAVL(0);
    }
    child.setAVL(0);

    //第一次交换
    parent.setRight(child);
    node.setParent(child);
    node.setLeft(child.getRight()); 
    if(child.getRight() != null)
        child.getRight().setParent(node);
    child.setRight(node);
    child.setParent(parent);

    //第二次交换
    if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getLeft()){
        child.setParent(parent.getParent());
        parent.getParent().setLeft(child);
    }else if(parent.getParent() != null &amp;&amp; parent == parent.getParent().getRight()){
        child.setParent(parent.getParent());
        parent.getParent().setRight(child);
    }else{
        root = child;
        child.setParent(null);
    }
    parent.setParent(child);
    parent.setRight(child.getLeft());
    if(child.getLeft() != null)
        child.getLeft().setParent(parent);
    child.setLeft(parent);
}
</code></pre><p>完整代码github地址：<a href="https://github.com/ziyuanjg/AVLTree" target="_blank" rel="external">https://github.com/ziyuanjg/AVLTree</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList源码阅读笔记（基于JDK1.8）]]></title>
      <url>/2017/06/19/JDKCode-4/</url>
      <content type="html"><![CDATA[<p>　　LinkedList是List接口的一个有序链表实现，存储节点是内部类Node，Node中有两个属性prev和next，负责连接前后两个元素。由于不是使用数组进行存储，所以查询需要遍历链表一半的元素（后面会解释），但是因为插入的时候只需要查询插入位置的元素，然后修改前后两个元素的对应属性即可，所以插入效率相对ArrayList较高（针对add(int index, E element)方法，add(E e)直接插入链表最后）。<br><a id="more"></a></p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre><code>public void addFirst(E e) {                   //添加元素到列表头
    linkFirst(e);
}
public void addLast(E e) {                    //添加元素到列表尾
    linkLast(e);
}
 public boolean add(E e) {                    //添加元素到列表头，会返回添加是否成功
    linkLast(e);
    return true;
}
public void add(int index, E element) {       //添加元素到index位置
    checkPositionIndex(index);                //检查index是否越界

    if (index == size)                        //如果index等于链表长度则插入到链表尾
        linkLast(element);
    else                                      //否则插入到链表头
        linkBefore(element, node(index));
}
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    //在index位置插入集合c的全部元素
    checkPositionIndex(index);                //检查index是否越界

    Object[] a = c.toArray();
    int numNew = a.length;
    if (numNew == 0)
        return false;

    Node&lt;E&gt; pred, succ;
    if (index == size) {                    //如果index为链表长度，则插入位置为链表尾
        succ = null;
        pred = last;
    } else {                                //否则将记录index位置的前一个元素，为之后连接链表准备
        succ = node(index);
        pred = succ.prev;
    }

    for (Object o : a) {                    //遍历参数集合，将元素依次插入实例集合
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);    
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        pred = newNode;
    }
</code></pre><p>　　　　//插入完毕，将原集合index之后的部分连接到链表尾<br>        if (succ == null) {<br>            last = pred;<br>        } else {<br>            pred.next = succ;<br>            succ.prev = pred;<br>        }</p>
<pre><code>    size += numNew;
    modCount++;
    return true;
}
public E set(int index, E element) {        //修改index位置元素为element
    checkElementIndex(index);
    Node&lt;E&gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}
</code></pre><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><pre><code>public E getFirst() {                         //获取链表头元素
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
}
public E getLast() {                         //获取链表尾元素
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
}
public E get(int index) {                    //获取链表index位置的元素
    checkElementIndex(index);
    return node(index).item;
}
Node&lt;E&gt; node(int index) {                    //获取特定位置元素的实现方法
    // assert isElementIndex(index);

    if (index &lt; (size &gt;&gt; 1)) {               //如果index小于链表长度的一半则从前向后遍历前一半链表
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {                                //如果index大于等于链表长度的一半则从后向前遍历后一半链表
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>public E removeFirst() {                       //删除链表头元素，类似pop
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
}
public E removeLast() {                        //删除链表尾元素
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}
private E unlinkFirst(Node&lt;E&gt; f) {             //删除链表头元素的实现方法
    // assert f == first &amp;&amp; f != null;
    final E element = f.item;
    final Node&lt;E&gt; next = f.next;
    f.item = null;
    f.next = null;                             // 这两个置为空是为了方便GC
    first = next;                              //第二个元素提置第一位，将原第一位元素踢出链表
    if (next == null)                          //如果没有next说明删除链表头元素后链表为空，将last置为空
        last = null;
    else                                       //next不为空说明删除后链表还存在元素，将现第一位元素的prev置为空（链表头元素prev为空）
        next.prev = null;
    size--;
    modCount++;
    return element;
}
 private E unlinkLast(Node&lt;E&gt; l) {             //删除链表尾元素的实现方法
    // assert l == last &amp;&amp; l != null;
    final E element = l.item;
    final Node&lt;E&gt; prev = l.prev;
    l.item = null;
    l.prev = null;                             //这两个置为空是为了方便GC
    last = prev;                               //将倒数第二个元素置为链表尾元素，将原链表尾元素踢出链表
    if (prev == null)                          //如果prev为空则说明删除链表尾元素后链表为空，没有已保存的元素，此时first为空
        first = null;
    else                                       //如果prev不为空，说明删除之后链表还存在元素，此时需将链表尾元素的next元素置为空（链表尾元素next为空）
        prev.next = null;
    size--;
    modCount++;
    return element;
}
public boolean remove(Object o) {               //删除指定元素实现方法
    if (o == null) {                            //遍历空对象
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (x.item == null) {               //如果有符合的元素则删除
                unlink(x);    
                return true;
            }
        }
    } else {
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {            //如果有符合的元素则删除
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
public E remove(int index) {                   //删除指定位置的元素
    checkElementIndex(index);
    return unlink(node(index));
}
public E remove() {                            //删除链表头元素
    return removeFirst();
}
E unlink(Node&lt;E&gt; x) {                          //删除指定元素实现方法
    // assert x != null;
    final E element = x.item;                  //参数元素的value，用于返回值
    final Node&lt;E&gt; next = x.next;               //参数元素的下一位元素
    final Node&lt;E&gt; prev = x.prev;               //参数元素的上一位元素

    if (prev == null) {                        //prev为空说明参数元素是链表头元素，将下一位元素提置链表头
        first = next;
    } else {                                   //将上一位元素和下一位元素相连
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {                        //如果next为空说明参数元素是链表尾元素，将上一位元素置为链表尾
        last = prev;
    } else {                                   //将上一位元素和下一位元素相连
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
public boolean removeLastOccurrence(Object o) {    //找到元素出现的最后位置并删除
    if (o == null) {
        for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
</code></pre><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>LinkedList的迭代实现和其他几个集合的实现相比要强大一些，不仅可以向后遍历，也可以向前遍历，而且包含了实现fail-fast的增删改操作。</p>
<pre><code>public E next() {                                     //获取下一个元素
        checkForComodification();
        if (!hasNext())
            throw new NoSuchElementException();

        lastReturned = next;
        next = next.next;
        nextIndex++;
        return lastReturned.item;
    }
public E previous() {                                 //获取上一个元素，需要注意的是当调用next然后调用previous时会返回同一个元素，因为调用next的时候nextIndex被加一，而previous中nextIndex减一，所以会取到同一个元素
        checkForComodification();
        if (!hasPrevious())
            throw new NoSuchElementException();

        lastReturned = next = (next == null) ? last : next.prev;
        nextIndex--;
        return lastReturned.item;
    }
public void remove() {                                //实现了fail-fast的删除
        checkForComodification();
        if (lastReturned == null)
            throw new IllegalStateException();

        Node&lt;E&gt; lastNext = lastReturned.next;
        unlink(lastReturned);
        if (next == lastReturned)
            next = lastNext;
        else
            nextIndex--;
        lastReturned = null;
        expectedModCount++;
    }

    public void set(E e) {                            //实现了fail-fast的修改
        if (lastReturned == null)
            throw new IllegalStateException();
        checkForComodification();
        lastReturned.item = e;
    }

    public void add(E e) {                            //实现了fail-fast的新增
        checkForComodification();
        lastReturned = null;
        if (next == null)
            linkLast(e);
        else
            linkBefore(e, next);
        nextIndex++;
        expectedModCount++;
    }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JDKCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList源码阅读笔记(基于JDk1.8)]]></title>
      <url>/2017/06/19/JDKCode-3/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　ArrayList是基于数组实现的一个有序的列表，允许添加null值.除了List接口中的方法外，还实现了一些操作数组元素和大小的方法，具体下面会列举。每个ArrayList实例都有一个元素数，即size属性，这个属性标注了在实例中包含了多少个元素，这些元素存储在elementData这个数组中，当实例的容量不足时，会调用grow方法进行扩容，通常情况下每次扩大一半容量，但是有两种特殊情况，一种是手动指定的容量大于当前容量的1.5倍时会按照指定容量扩容，另一种是当前容量的1.5倍大于MAX_ARRAY_SIZE这个值的时候会扩容至Integer.MAX_VALUE或MAX_ARRAY_SIZE。</p>
<a id="more"></a>
<h2 id="关键常量"><a href="#关键常量" class="headerlink" title="关键常量"></a>关键常量</h2><table>
<thead>
<tr>
<th style="text-align:left">常量名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">private static final int DEFAULT_CAPACITY = 10</td>
<td style="text-align:left">当没有其他参数影响数组大小时的默认数组大小</td>
</tr>
<tr>
<td style="text-align:left">private static final Object[] EMPTY_ELEMENTDATA = {}</td>
<td style="text-align:left">如果elementData用这个变量初始化，则DEFAULT_CAPACITY不会参与数组大小的运算</td>
</tr>
<tr>
<td style="text-align:left">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</td>
<td style="text-align:left">如果elementData用这个变量初始化，则DEFAULT_CAPACITY会参与数组大小的运算,只有ArrayList()中有调用</td>
</tr>
<tr>
<td style="text-align:left">transient Object[] elementData</td>
<td style="text-align:left">实际存储数据的数组</td>
</tr>
<tr>
<td style="text-align:left">private int size</td>
<td style="text-align:left">数组大小</td>
</tr>
<tr>
<td style="text-align:left">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</td>
<td style="text-align:left">之所以减8是因为不同的vm有不同的保留字会占用一部分容量</td>
</tr>
</tbody>
</table>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
public ArrayList(int initialCapacity) {       //指定容量
    if (initialCapacity &gt; 0) {                //指定容量&gt;0，则按照指定的容量构建数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {        //指定容量=0，则构造默认空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity);
    }
}
public ArrayList(Collection&lt;? extends E&gt; c) {      //通过一个集合构造数组
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {        //参数集合不为空，则将实例构造成Object[]
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {                                       //参数集合为空，则将实例构造成默认空数组
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><pre><code>public boolean add(E e) {
    ensureCapacityInternal(size + 1);      //扩容操作
    elementData[size++] = e;
    return true;
}
public void add(int index, E element) {　　//添加元素到指定位置
    rangeCheckForAdd(index);               //检查index是否越界

    ensureCapacityInternal(size + 1); 
    System.arraycopy(elementData, index, elementData, index + 1,size - index);
    elementData[index] = element;
    size++;
}
public boolean addAll(Collection&lt;? extends E&gt; c) {    //将参数集合添加至实例
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}
 public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    //将参数集合添加至实例指定位置
    rangeCheckForAdd(index);                //检查index是否越界

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;            //这里要注意，插入前会将原数组从index位置分开
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}
</code></pre><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><pre><code>public E set(int index, E element) {        
    //新增会将index位置之后的元素依次后移，而覆盖会将index位置的元素替换，对其他位置的元素没有影响
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}
</code></pre><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre><code>public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>public E remove(int index) {        
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,        //删除元素之后会将index之后的元素依次向前一位
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)        //遍历数组直到找到指定元素并删除
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)        //遍历数组直到找到指定元素并删除
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}
</code></pre><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><pre><code>public void clear() {
    modCount++;

    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}   
</code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre><code>private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {    //当使用第一种构造方法时，第一次执行扩容方法会进入这个分支，将容量扩展为默认大小（10）
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    if (minCapacity - elementData.length &gt; 0)                   //如果参数长度大于数组长度则会扩容
        grow(minCapacity);
}
private void grow(int minCapacity) {    
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        //默认每次增长为1.5倍
    if (newCapacity - minCapacity &lt; 0)                           //特例1：参数大于数组长度的1.5倍，此时按照参数扩容
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)                       //特例2：数组长度的1.5倍大于MAX_ARRAY_SIZE，此时将数组扩容至MAX_ARRAY_SIZE 或Integer.MAX_VALUE
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>ArrayList的迭代器也具备快速失败机制，具体是通过checkForComodification()进行控制：</p>
<pre><code>final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
</code></pre><p>如果并发线程对实例进行增删操作，则迭代器会抛出异常以防止在不确定的时间发生某种行为带来的未知风险。</p>
]]></content>
      
        
        <tags>
            
            <tag> JDKCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedHashMap源码阅读笔记（基于jdk1.8）]]></title>
      <url>/2017/06/19/JDKCode-2/</url>
      <content type="html"><![CDATA[<p>　　LinkedHashMap是HashMap的子类，很多地方都是直接引用HashMap中的方法，所以需要注意的地方并不多。关键的点就是几个重写的方法：</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>　　Entry是继承与Node类，也就是LinkedHashMap与HashMap的根本区别所在，Node是链表形式，只有next与下一个元素进行连接，而Entry的链表有before和after两个连接点。</p>
<pre><code>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre><a id="more"></a>
<h2 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h2><p>　　区别是将节点变成Entry，并且按照链表方式将元素有序连接</p>
<pre><code>Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
</code></pre><h2 id="红黑树节点"><a href="#红黑树节点" class="headerlink" title="红黑树节点"></a>红黑树节点</h2><p>　　红黑树节点类型并没有改变，也只是按照链表方式连接</p>
<pre><code>TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
    TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next);
    linkNodeLast(p);
    return p;
}
</code></pre><p>　　HashMap中为LinkedHashMap留下了三个预留方法：</p>
<h3 id="第一个比较好理解，在删除元素e的时候将e前后的元素相连。"><a href="#第一个比较好理解，在删除元素e的时候将e前后的元素相连。" class="headerlink" title="第一个比较好理解，在删除元素e的时候将e前后的元素相连。"></a>第一个比较好理解，在删除元素e的时候将e前后的元素相连。</h3><pre><code>void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    LinkedHashMap.Entry&lt;K,V&gt; p =
        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    p.before = p.after = null;
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
</code></pre><h3 id="这个方法表面上看是判断是否删除链表中第一个元素，但是实际上是为重写LRU而准备的。"><a href="#这个方法表面上看是判断是否删除链表中第一个元素，但是实际上是为重写LRU而准备的。" class="headerlink" title="这个方法表面上看是判断是否删除链表中第一个元素，但是实际上是为重写LRU而准备的。"></a>这个方法表面上看是判断是否删除链表中第一个元素，但是实际上是为重写LRU而准备的。</h3><pre><code>void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
</code></pre><p>关键就是下面这个方法，在LinkedHashMap中默认返回是false，当需要实现LRU算法的时候继承LinkedHashMap的子类重写这个方法即可，LRU内容较多，稍后会单开一贴记录。</p>
<pre><code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre><h3 id="第三个方法主要是将元素移到链表的最后一位，关键参数是accessOrder，这个参数只有在public-LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder-中可以手动设置为true，其余时候都默认为false，所以这个方法实际用到的地方比较少。"><a href="#第三个方法主要是将元素移到链表的最后一位，关键参数是accessOrder，这个参数只有在public-LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder-中可以手动设置为true，其余时候都默认为false，所以这个方法实际用到的地方比较少。" class="headerlink" title="第三个方法主要是将元素移到链表的最后一位，关键参数是accessOrder，这个参数只有在public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) 中可以手动设置为true，其余时候都默认为false，所以这个方法实际用到的地方比较少。"></a>第三个方法主要是将元素移到链表的最后一位，关键参数是accessOrder，这个参数只有在public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) 中可以手动设置为true，其余时候都默认为false，所以这个方法实际用到的地方比较少。</h3><pre><code>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre><p>accessOrder这个参数的实际意义是控制链表get的时候是按照插入顺序还是访问顺序，比如下面的例子：</p>
<pre><code>Map&lt;String,String&gt; m = new LinkedHashMap(16,0.75F,true);
    m.put(&quot;1&quot;, &quot;a&quot;);
    m.put(&quot;2&quot;, &quot;b&quot;);
    m.put(&quot;3&quot;, &quot;c&quot;);
    m.put(&quot;4&quot;, &quot;d&quot;);
    m.get(&quot;1&quot;);
    m.get(&quot;2&quot;);
    m.forEach((x,y)-&gt;{System.out.println(y);});
</code></pre><p>这时的输出是cdab，如果accessOrder设置为false则输出abcd。</p>
<p>　　这种链表形式其实在调用get方法的时候没有什么差别，存储方式也没有什么差别，差别在于forEach这个方法。HashMap中想要遍历所有元素只能通过三种set集合的迭代器，但是LinkedHashMap自身实现了forEach方法，而且在put的时候队元素进行了排序，所以可以直接对自身进行遍历。</p>
]]></content>
      
        
        <tags>
            
            <tag> JDKCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码阅读笔记（基于jdk1.8）]]></title>
      <url>/2017/06/19/JDKCode-1/</url>
      <content type="html"><![CDATA[<h2 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h2><p>　　HashMap是基于Map接口的一个非同步实现，此实现提供key-value形式的数据映射，支持null值。<br><a id="more"></a><br>HashMap的常量和重要变量如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DEFAULT_INITIAL_CAPACITY = 16</td>
<td style="text-align:left">Node数组的默认长度</td>
</tr>
<tr>
<td style="text-align:left">MAXIMUM_CAPACITY = 1073741824</td>
<td style="text-align:left">Node数组的最大长度</td>
</tr>
<tr>
<td style="text-align:left">DEFAULT_LOAD_FACTOR = 0.75F</td>
<td style="text-align:left">负载因子，调控控件与冲突率的因数</td>
</tr>
<tr>
<td style="text-align:left">TREEIFY_THRESHOLD = 8</td>
<td style="text-align:left">链表转换为树的阈值，超过这个长度的链表会被转换为红黑树</td>
</tr>
<tr>
<td style="text-align:left">UNTREEIFY_THRESHOLD = 6</td>
<td style="text-align:left">当进行resize操作时，小于这个长度的树会被转换为链表</td>
</tr>
<tr>
<td style="text-align:left">MIN_TREEIFY_CAPACITY = 64</td>
<td style="text-align:left">链表被转换成树形的最小容量，如果没有达到这个容量只会执行resize进行扩容</td>
</tr>
<tr>
<td style="text-align:left">Node<k, v="">[] table</k,></td>
<td style="text-align:left">储存元素的数组</td>
</tr>
<tr>
<td style="text-align:left">Set<map.entry<k, v="">&gt; entrySet</map.entry<k,></td>
<td style="text-align:left">set数组，用于迭代元素</td>
</tr>
<tr>
<td style="text-align:left">int size</td>
<td style="text-align:left">存放元素的个数，但不等于数组的长度</td>
</tr>
<tr>
<td style="text-align:left">int modCount</td>
<td style="text-align:left">每次扩容和更改map结构的计数器</td>
</tr>
<tr>
<td style="text-align:left">int threshold</td>
<td style="text-align:left">临界值，当实际大小（容量*负载因子）超过临界值的时候，会进行扩容</td>
</tr>
<tr>
<td style="text-align:left">float loadFactor</td>
<td style="text-align:left">负载因子，默认为0.75F</td>
</tr>
</tbody>
</table>
<h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p>　　在jdk1.8中，HashMap是采用数组+链表+红黑树的形式实现。如下图：<br><img src="/images/mybatis_29.png" alt=""></p>
<p>　　其中链表的实现如下：</p>
<pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + &quot;=&quot; + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
</code></pre><p>　　可以看到，node中包含一个next变量，这个就是链表的关键点，hash结果相同的元素就是通过这个next进行关联的。</p>
<p>　　接下来看看红黑树的实现：</p>
<pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent;  // red-black tree links
    TreeNode&lt;K,V&gt; left;
    TreeNode&lt;K,V&gt; right;
    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
    boolean red;
    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
        super(hash, key, val, next);
    }
</code></pre><p>　　　……<br>    }</p>
<p>　　红黑树比链表多了四个变量，parent父节点、left左节点、right右节点、prev上一个同级节点，红黑树内容较多，有兴趣的可以自行百度，不在赘述。</p>
<p>　　在来说说hash算法，HashMap中使用的算法如下</p>
<pre><code>static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>　　这个hash先将key右移了16位，然后与key进行异或，这里还涉及到后面put方法中的另一次&amp;操作，</p>
<pre><code>tab[i = (n - 1) &amp; hash]
</code></pre><p>　　tab既是table，n是map集合的容量大小，hash是上面方法的返回值。因为通常声明map集合时不会指定大小，或者初始化的时候就创建一个容量很大的map对象，所以这个通过容量大小与key值进行hash的算法在开始的时候只会对低位进行计算，虽然容量的2进制高位一开始都是0，但是key的2进制高位通常是有值的，因此先在hash方法中将key的hashCode右移16位在与自身异或，使得高位也可以参与hash，更大程度上减少了碰撞率。</p>
<p>　　构造方法如下：</p>
<pre><code>public HashMap()                                             //默认构造方法
public HashMap(int initialCapacity)                          //参数为初始大小
public HashMap(int initialCapacity, float loadFactor)        //参数为初始大小，负载因子
</code></pre><p>　　这里又涉及到另一个算法：</p>
<pre><code>static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre><p>　　这个算法很有意思，通过给定的大小cap，计算大于等于cap的最小的2的幂数。连续5次右移运算乍一看没有什么意思，但仔细一想2进制都是0和1啊，这就有问题了，第一次右移一位，就表示但凡是1的位置右边的一位都变成了1，第二次右移两位，上次已经把有1的位置都变成连续两个1了，是不是感觉很神奇，如此下来5次运算正好将int的32位都转了个遍，以最高的一个1的位置为基准将后面所有位数都变为1，然后在进行n+1，不就变成了2的幂数。这里还有一点要注意的是第一行的cap-1，这是因为如果cap本身就是2的幂数，会出现结果是cap的2倍的情况，会浪费空间。</p>
<h2 id="HashMap的存取"><a href="#HashMap的存取" class="headerlink" title="HashMap的存取"></a>HashMap的存取</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {                       //put方法的实际执行者
        //hash，key的hash值；onlyIfAbsent，是否改变原有值；evict，LinkedHashMap回调时才会用到。
        Node&lt;K,V&gt;[] tab; 
        Node&lt;K,V&gt; p; 
        int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;                                                              //table为空或长度为0时，对table进行初始化，分配内存
     　 if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);                                                 //当put的key在map中不存在时，直接new一个Node存入table。
        else {                                                                                        //当key在map中存在时，进入此分支。
            　Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))             //此处的p是table中的第n-1个元素，每一次必检查此元素的key是否与put的key相同，如果相同则替换value
                e = p;
            else if (p instanceof TreeNode)                                                           //检查p是否是TreeNode类型。
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {                                                                                    //如果第n-1个元素不符合，则一次遍历table中其余元素，直到找到相应key值。
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {                                                       //此处主要为了防止hash出现重复，只有上边tab[i = (n - 1) &amp; hash]中存在元素且不是put的元素时才会进入这个分支。
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)                                        // 此处判断的意义是当链表长度超过8时，转换为红黑树，在1.8以前是没有的，链表查询的复杂度是O(n)，而红黑树是O(log(n))，但是如果hash结果不均匀会极大的影响性能
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))     //进入此分支标志已找到与put的key值相同的元素，元素变量为e。
                    　　break;
                    p = e;
                }
            }
               if (e != null) {                                                                       // 将对应key的value替换为put的value，同时返回旧value，只有存在key时才会返回！
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);    
                return oldValue;
               }
        }
    ++modCount;
    if (++size &gt; threshold)
        resize();                                                                                    //对table进行扩容
    afterNodeInsertion(evict);    
    return null;
}    
</code></pre><p>　　从上面的源码可以看出，首先会判断key的hash与map容量-1的与计算值，如果数组中这个位置没有元素则直接插入，反之则在遍历此位置的元素链表，直到在最后插入。这个地方有一个链表的阈值（默认是8），如果一个链表的长度达到了阈值，则调用treefyBin()将链表转换成红黑树。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre><code>final Node&lt;K,V&gt;[] resize() {                                      //扩容方法
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;            //map现在的容量
    int oldThr = threshold;                            
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
        if (oldCap &gt;= MAXIMUM_CAPACITY) {                         //如果现在的容量大于等于设定的最大容量则不会进行扩容
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1;                                 //如果现在的容量扩大为2倍依然没有超过最大容量，并且现在的容量大于等于数组的默认长度，将map的容量扩大为2倍
    }
    else if (oldThr &gt; 0)                                          //hashMap有一个构造方法会指定初始大小，这时候就会用到这个分支，对map进行初始化
        newCap = oldThr;
    else {                                                        //这个分支是默认的初始化参数分支，比如用new hashMap()生成一个对象，就会进入这个分支初始化
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {                                         //扩容操作，将oldTab的元素依次添加到newTab
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre><p>　　在这个方法里有几个比较有意思的地方，首先是最大容量MAXIMUN_CAPACITY，这个值实际就是int的最大值，个人推测应该是为了配合put时的hash算法，因为计算key值hash的算法返回值是int型，如果容量超过int的阈值，在进行与运算时碰撞率会增大很多倍。然后是扩容的方式，这里是new了一个数组！这也是HashMap不安全的关键之一。当超过一个线程对一个HashMap对象进行put的时候如果触发了resize方法，后执行的那一个会把之前执行的结果覆盖掉！也就是先put的值不会真的存入map中。</p>
<h3 id="链表转换为红黑树"><a href="#链表转换为红黑树" class="headerlink" title="链表转换为红黑树"></a>链表转换为红黑树</h3><pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {                     //将链表转换为红黑树
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        //如果map的容量小于64（默认值），会调用resize扩容，不会转换为红黑树
        resize();
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            //Node转换为TreeNode
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)    
            hd.treeify(tab);                                           //调用TreeNode的树排序方法
    }
}
</code></pre><p>　　这里需要注意的是当map容量小于64时，就算链表超过了8也不会转换为红黑树。</p>
<h3 id="Map克隆"><a href="#Map克隆" class="headerlink" title="Map克隆"></a>Map克隆</h3><pre><code>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {    //主要用于clone方法和putAll方法和一个构造方法HashMap(Map&lt;? extends K, ? extends V&gt; m)。
    int s = m.size();
    if (s &gt; 0) {    
        if (table == null) {                                                  // 如果是一个new的map，即table变量还没有初始化，先通过参数的map.size和负载因子计算所需的map大小。
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            if (t &gt; threshold)                                                //如果计算出的大小大于map的实际存储容量，则重新计算存储容量
                threshold = tableSizeFor(t);
        }
        else if (s &gt; threshold)                                               //如果参数map大小大于实际存储容量，则将map容量变为2倍
            resize();
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {          //遍历赋值
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
</code></pre><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre><code>final Node&lt;K,V&gt; getNode(int hash, Object key) {                                //get的实际实现方法
    Node&lt;K,V&gt;[] tab;
    Node&lt;K,V&gt; first, e; 
    int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {          //通过hash定位到一个桶，并且有元素存在
        if (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))             //总是检查桶中的第一个元素
            return first;
        if ((e = first.next) != null) {                                        //如果第一个元素不符合，则继续搜索
            if (first instanceof TreeNode)                                     //如果桶中是红黑树，进入此分支，实际执行的是TreeNode中的find方法，从根节点开始向下搜寻
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {                                                               //如果是链表结构则依次遍历
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><p>　　看过put方法后再来看get就容易很多了，首先用put中的hash算法定位到数组中的位置，如果有元素且key值相同直接返回，如果有元素且key值不同那就要向下遍历了，如果是链表就一直遍历next，如果是红黑树则调用getTreeNode方法查找节点。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>abstract class HashIterator {                                                  //KeySet和EntrySet的迭代器的父类
    Node&lt;K,V&gt; next;                                                            // 下一个元素
    Node&lt;K,V&gt; current;                                                         // 删除方法会调用
    int expectedModCount;                                                      // 就是hashMap中的modCount
    int index;                                                                 // 元素序号

    HashIterator() {                                                           //为上面四个变量赋初始值
        expectedModCount = modCount;
        Node&lt;K,V&gt;[] t = table;
        current = next = null;
        index = 0;
        if (t != null &amp;&amp; size &gt; 0) { // advance to first entry
            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
        }
    }
    .......
}
</code></pre><p>　　HashIterator是KerSet和EntrySet的父类，这个迭代器中有一个属性是expectedModCount要特别注意，这个变量等价于HashMap对象中的modCount，如果在迭代器没有执行完的期间对map进行增删，会抛出异常阻止继续迭代，代码如下：</p>
<pre><code>final Node&lt;K,V&gt; nextNode() {                                                  //获取下一个元素
    Node&lt;K,V&gt;[] t;
    Node&lt;K,V&gt; e = next;
    if (modCount != expectedModCount)                                         //在迭代器执行期间只能用下面的remove删除元素，否则会抛出异常，不能增加元素
        throw new ConcurrentModificationException();
        if (e == null)                                                        //如果没有下一个会抛出异常
            throw new NoSuchElementException();
        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {     //如果next没有取到值，通过index继续向下遍历，直到取到元素为止
            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
        }
        return e;
    }
</code></pre><p>　　不过迭代器虽然不允许添加元素，但是给了一个删除的方法：</p>
<pre><code>public final void remove() {                                                  //删除方法
        Node&lt;K,V&gt; p = current;
        if (p == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        current = null;
        K key = p.key;
        removeNode(hash(key), key, null, false, false);
        expectedModCount = modCount;                                          //关键语句，这里做了一个同步，否则与正常的删除没有区别，这个同步避免了上面的异常抛出
    }
</code></pre><p>　　与普通的删除方法就差在最后这一行上，这里同步了迭代器和HashMap对象的操作数，便不会抛出异常。</p>
]]></content>
      
        
        <tags>
            
            <tag> JDKCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：动态SQL]]></title>
      <url>/2017/06/15/mybatis-12/</url>
      <content type="html"><![CDATA[<h2 id="MyBatis中和动态SQl相关的类"><a href="#MyBatis中和动态SQl相关的类" class="headerlink" title="MyBatis中和动态SQl相关的类"></a>MyBatis中和动态SQl相关的类</h2><h3 id="BaseBuilder"><a href="#BaseBuilder" class="headerlink" title="BaseBuilder"></a>BaseBuilder</h3><p><img src="/images/mybatis_24.png" alt=""><br><a id="more"></a></p>
<p>BaseBuilder主要负责解析xml配置文件，以及构建各种相关的实例：</p>
<ul>
<li>XMLConfigBuilder：解析全局xml配置文件</li>
<li>XMLMapperBuilder：解析mapper节点配置</li>
<li>XMLStatementBuilder：解析CRUD节点配置</li>
<li>XMLScriptBuilder：解析节点中的sql</li>
<li>MapperBuilderAssistant：辅助构建工具类</li>
<li>SqlSourceBuilder：sql源构建类</li>
</ul>
<h3 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h3><p><img src="/images/mybatis_25.png" alt=""></p>
<p>SqlNode对应的就是动态sql的各种标签了：</p>
<ul>
<li>ChooseSqlNode：对应choose标签，类似于switch功能</li>
<li>ForEachSqlNode：对应forEach标签</li>
<li>IfSqlNode：对应if标签和when标签</li>
<li>MixedSqlNode：SqlNode集合类，内部维护了一个SqlNode集合，储存一个Statement中的所有动态sql节点元素</li>
<li>StaticTextSqlNode：静态sql节点</li>
<li>TextSqlNode：文本型节点的默认类型</li>
<li>TrimSqlNode：过滤sql前后缀，支持set和where类型</li>
<li>SetSqlNode：TrimSqlNode的set调用</li>
<li>WhereSqlNode：TrimSqlNode的where调用</li>
<li>VarDeclSqlNode：对应bind标签，用于解析Ognl表达式</li>
</ul>
<h3 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h3><p><img src="/images/mybatis_26.png" alt=""><br>SqlSource是处理xml配置文件中的sql部分的工具：</p>
<ul>
<li>DynamicSqlSource：创建动态sqlSourse</li>
<li>ProviderSqlSource：处理通用mapper</li>
<li>RawSqlSource：处理静态sql</li>
<li>StaticSqlSource：创建静态sqlSourse</li>
</ul>
<h3 id="LanguageDriver"><a href="#LanguageDriver" class="headerlink" title="LanguageDriver"></a>LanguageDriver</h3><p>　　LanguageDriver主要实现类是XMLLanguageDriver，XMLLanguageDriver内部使用XMLScriptBuilder解析sql节点，用于生成SqlSource。</p>
<h2 id="动态Sql创建流程"><a href="#动态Sql创建流程" class="headerlink" title="动态Sql创建流程"></a>动态Sql创建流程</h2><p><img src="/images/mybatis_26.png" alt=""></p>
<p>　　mapper的路径既然是在全局xml中配置的，那么入口自然也要落在创建运行环境上下文中</p>
<pre><code>private void parseConfiguration(XNode root) {
    try {
      //TODO
      //此处进入解析mappers节点流程
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
  }
private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        if (&quot;package&quot;.equals(child.getName())) {
          //如果配置的是package，会遍历包下所有的mapper进行注册
          String mapperPackage = child.getStringAttribute(&quot;name&quot;);
          configuration.addMappers(mapperPackage);
        } else {
          //三种配置方式由县级为Resource&gt;url&gt;class
          String resource = child.getStringAttribute(&quot;resource&quot;);
          String url = child.getStringAttribute(&quot;url&quot;);
          String mapperClass = child.getStringAttribute(&quot;class&quot;);
          if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
            ErrorContext.instance().resource(resource);
            InputStream inputStream = Resources.getResourceAsStream(resource);
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
            //处理内部mapper节点
            mapperParser.parse();
          } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
            ErrorContext.instance().resource(url);
            InputStream inputStream = Resources.getUrlAsStream(url);
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
            mapperParser.parse();
          } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
            configuration.addMapper(mapperInterface);
          } else {
            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
          }
        }
      }
    }
  }
</code></pre><p>　　下面就进入了XMLMapperBuilder中：</p>
<pre><code>public void parse() {
    if (!configuration.isResourceLoaded(resource)) {
      //避免重复加载同一mapper
      //解析mapper节点
      configurationElement(parser.evalNode(&quot;/mapper&quot;));
      //在缓存中添加mapper标识，避免重复加载
      configuration.addLoadedResource(resource);
      //绑定命名空间
      bindMapperForNamespace();
    }

    parsePendingResultMaps();
    parsePendingChacheRefs();
    parsePendingStatements();
  }

private void configurationElement(XNode context) {
    try {
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      if (namespace == null || namespace.equals(&quot;&quot;)) {
        throw new BuilderException(&quot;Mapper&apos;s namespace cannot be empty&quot;);
      }
      builderAssistant.setCurrentNamespace(namespace);
      //处理缓存标签，cache会覆盖cache-ref
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      cacheElement(context.evalNode(&quot;cache&quot;));
      //已废弃，不推荐使用
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      //处理外部resultMap引用
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      //处理sql片段
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      //处理CRUD，也是动态sql的关键
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
    }
  }

  private void buildStatementFromContext(List&lt;XNode&gt; list) {
    if (configuration.getDatabaseId() != null) {
      buildStatementFromContext(list, configuration.getDatabaseId());
    }
    buildStatementFromContext(list, null);
  }

  private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) {
    for (XNode context : list) {
      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
      try {
        statementParser.parseStatementNode();
      } catch (IncompleteElementException e) {
        configuration.addIncompleteStatement(statementParser);
      }
    }
  }
</code></pre><p>　　接下来进入XMLStatementBuilder 处理具体sql内容：</p>
<pre><code>public void parseStatementNode() {
    //.....
    LanguageDriver langDriver = getLanguageDriver(lang);
    //.....
    //创建sql源
    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
    //.......
  }
</code></pre><p>　　由于是动态sql，所以下面进入XMLLanguageDriver实现：</p>
<pre><code>public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) {
    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
    return builder.parseScriptNode();
  }
</code></pre><p>　　XMLLanguageDriver很懒，立即将任务转给了XMLScriptBuilder：</p>
<pre><code>public SqlSource parseScriptNode() {
    //遍历sql中的所有节点，判断是动态sql还是静态sql
    List&lt;SqlNode&gt; contents = parseDynamicTags(context);
    //MixedSqlNode表示sql节点集合
    MixedSqlNode rootSqlNode = new MixedSqlNode(contents);
    SqlSource sqlSource = null;
    if (isDynamic) {
      //动态sql
      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);
    } else {
      //静态sql
      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);
    }
    return sqlSource;
  }
</code></pre><p>　　至此就完成了mapper配置文件的读取注册流程。</p>
<h2 id="通过sql模板生成动态sql流程"><a href="#通过sql模板生成动态sql流程" class="headerlink" title="通过sql模板生成动态sql流程"></a>通过sql模板生成动态sql流程</h2><p><img src="/images/mybatis_28.png" alt=""></p>
<p>　　既然是动态sql，那自然是运行时才会根据参数生成执行sql了，下面以query为例，简析生成动态sql的流程：<br>　　首先在CachingExecutor中调用query</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
</code></pre><p>　　可以看到此时调用了MappedStatement的getBoundSql方法，申请创建BoundSql实例</p>
<pre><code>public BoundSql getBoundSql(Object parameterObject) {
  //根据参数动态生成sql对象
  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
  //参数队列
  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
  if (parameterMappings == null || parameterMappings.isEmpty()) {
    boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);
  }

  for (ParameterMapping pm : boundSql.getParameterMappings()) {
    String rmId = pm.getResultMapId();
    if (rmId != null) {
      ResultMap rm = configuration.getResultMap(rmId);
      if (rm != null) {
        hasNestedResultMaps |= rm.hasNestedResultMaps();
      }
    }
  }
  return boundSql;
}
</code></pre><p>　　由于是动态sql，所以此时的sqlSource是DynamicSqlSource类型</p>
<pre><code>public BoundSql getBoundSql(Object parameterObject) {
    DynamicContext context = new DynamicContext(configuration, parameterObject);
    //遍历本sql下的所有子标签（如if，forEach等），与参数进行匹配，生成最终要执行的sql。
    rootSqlNode.apply(context);
    //SQLSource的创建者
    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);
    //获取参数类型
    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();
    //创建SQLSource实例，此处其实也是使用的StaticSqlSource
    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());
    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
    //将parameterObject和DatabaseId放入boundSql中
    for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) {
      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());
    }
    return boundSql;
  }
</code></pre><p>　　值得关注的是rootSqlNode.apply(context)，这个方法就是组装动态节点的入口。在上面的创建流程中有提到动态sql的节点集合是包装在MixedSqlNode中的，此处的rootSqlNode自然也就是MixedSqlNode类型</p>
<pre><code>public boolean apply(DynamicContext context) {
    for (SqlNode sqlNode : contents) {
      sqlNode.apply(context);
    }
    return true;
  }
</code></pre><p>　　在apply中将集合中的参数依次取出，依次拼接。以if标签对应的IfSqlNode为例：</p>
<pre><code>public boolean apply(DynamicContext context) {
    if (evaluator.evaluateBoolean(test, context.getBindings())) {
      contents.apply(context);
      return true;
    }
    return false;
  }
</code></pre><p>　　此时便完成了sql的动态生成。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：Plugin]]></title>
      <url>/2017/06/15/mybatis-11/</url>
      <content type="html"><![CDATA[<p>　　Plugin类实现了InvocationHandler接口，  是MyBatis对java动态代理的一个扩展，用来支持Mybatis自身的plugins插件开发。</p>
<h2 id="Plugin可以做什么"><a href="#Plugin可以做什么" class="headerlink" title="Plugin可以做什么"></a>Plugin可以做什么</h2><p>　　作为一个插件模块，Plugin实际上是一种拦截器，在SqlSession的执行流程中不难发现，其实在创建Executor、StatementHandler、ResultSetHandler、ParameterHandler的实例时都会使用Configuration中的插件队列依次进行代理，结合MetaObject就可以对sql的执行过程做一些定制化的修改，比如常用的分页，分库分表，读写分离，分类缓存等。<br><a id="more"></a></p>
<h2 id="Plugin如何工作"><a href="#Plugin如何工作" class="headerlink" title="Plugin如何工作"></a>Plugin如何工作</h2><p><img src="/images/mybatis_23.png" alt=""></p>
<p>　　要使用Plugin首先要在config中进行配置</p>
<pre><code>&lt;plugins&gt;
    &lt;plugin interceptor=&quot;interceptor.ExampleInterceptor&quot;&gt;&lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre><p>　　在MyBatis初始化的时候创建了运行环境（Configuration），那Plugin自然也脱离不了这个范畴，在Configuration中有四个触发点会对拦截器进行注册，下面来看一个例子：</p>
<pre><code>public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
   ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
   return parameterHandler;
 }
</code></pre><p>　　此处调用了interceptorChain.pluginAll，这个interceptorChain顾名思义就是拦截器链</p>
<pre><code>public Object pluginAll(Object target) {
    for (Interceptor interceptor : interceptors) {
      target = interceptor.plugin(target);
    }
    return target;
  }
</code></pre><p>　　在pluginAll方法中每次都会将拦截器链中的所有实例依次代理指定类，既每次创建ParameterHandler、ResultSetHandler、StatementHandler、Executor实例的时候都会用所有已注册的拦截器进行代理，性能消耗真心大！</p>
<pre><code>public Object plugin(Object target) {
        return Plugin.wrap(target, this);
    }
public static Object wrap(Object target, Interceptor interceptor) {
    //获取Interceptor的拦截类和方法
    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);
    Class&lt;?&gt; type = target.getClass();
    //匹配传入对象target是否实现Interceptor指定拦截的接口
    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);
    if (interfaces.length &gt; 0) {
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }
</code></pre><p>　　下面看下plugin的调用流程，以拦截StatementHandler的prepare方法为例，因为Plugin的存在，首先会执行invoke方法</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());
      //匹配当前执行方法是否存在对应拦截器
      if (methods != null &amp;&amp; methods.contains(method)) {
        //存在则执行拦截器的intercept方法
        return interceptor.intercept(new Invocation(target, method, args));
      }
      return method.invoke(target, args);
    } catch (Exception e) {
      throw ExceptionUtil.unwrapThrowable(e);
    }
  }
</code></pre><p>　　如果存在此方法的拦截器，则调用拦截器的intercept方法，下面展示了几种常用变量的获取方式：</p>
<pre><code>public Object intercept(Invocation invocation) throws Throwable {
        //statementHandler
        MetaObject statementHandler = MetaObject.forObject(invocation.getTarget(), new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());
        //具体执行的statementHandler，此处是PreparedStatementHandler
        MetaObject ps = statementHandler.metaObjectForProperty(&quot;delegate&quot;);
        //MappedStatement
        MappedStatement ms = (MappedStatement) ps.getValue(&quot;mappedStatement&quot;);
        //Configuration
        Configuration config = (Configuration) ps.getValue(&quot;configuration&quot;);
        //参数对象
        Object parameterObject = statementHandler.getValue(&quot;parameterHandler.parameterObject&quot;);
        //sql对象
        BoundSql bs = (BoundSql) statementHandler.getValue(&quot;boundSql&quot;); 
  //执行被拦截方法
        return invocation.proceed();
    }
</code></pre><h2 id="多个Plugin的执行顺序"><a href="#多个Plugin的执行顺序" class="headerlink" title="多个Plugin的执行顺序"></a>多个Plugin的执行顺序</h2><p>　　上边既然提到了拦截器链，那自然是可以配置多个Plugin的</p>
<pre><code>&lt;plugins&gt;
         &lt;plugin interceptor=&quot;interceptor.Interceptor1&quot;&gt;&lt;/plugin&gt;
         &lt;plugin interceptor=&quot;interceptor.Interceptor2&quot;&gt;&lt;/plugin&gt;
         &lt;plugin interceptor=&quot;interceptor.Interceptor3&quot;&gt;&lt;/plugin&gt;
 &lt;/plugins&gt;
</code></pre><p>　　上面配置了三个Plugin，在创建运行环境（Configuration）时会依次将Plugin注册在拦截器中，但是为对象绑定代理时顺序则出现了一些不一样的地方，代理的执行顺序却不一定与绑定的顺序一致。如上面的intercept方法：</p>
<pre><code>public Object intercept(Invocation invocation) throws Throwable {
        //TODO1
  invocation.proceed();
        //TODO2
    }
</code></pre><p>　　如果是这种形式的拦截器，则会先执行TODO1，然后执行下级拦截器，之后再转回TODO2。</p>
<h2 id="拦截器的优缺点"><a href="#拦截器的优缺点" class="headerlink" title="拦截器的优缺点"></a>拦截器的优缺点</h2><p>　　在漫长的开发过程中，因为人自身的问题导致的程序bug层出不穷，框架就是在这种情况下应运而生，框架简化了编码的操作，极大的拉进了技术人员的差距，但是框架也封装了底层的操作，使得开发人员对程序的把控程度更低了，如果框架的一小部分不适合实际的业务，但是又无法更换框架的时候就需要Plugin这种存在，Plugin是MyBatis主动提供出来的流程修改入口，只要你想，甚至可以改变SqlSession的执行流程。</p>
<p>　　Plugin可以使得开发人员可以根据具体业务对MyBatis的底层做适当的干涉，但是这里就牵涉到第一个问题，人员的问题，如果开发人员自身技术不是很深入，有可能导致整个流程崩溃！一定要慎用！而且过多的拦截器会极大的消耗服务器资源，导致运行缓慢。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：MetaObject]]></title>
      <url>/2017/06/15/mybatis-10/</url>
      <content type="html"><![CDATA[<p>　　MyBatis作为一款ORM框架，反射是必不可少的一环，reflection就是MyBatis的反射模块。从代码角度来看reflection包相当的独立，除了jdk之外没有其他的包外引用，完全可以单独提取出来作为工具使用。<br><a id="more"></a><br><img src="/images/mybatis_18.png" alt=""></p>
<h2 id="MetaObject创建流程"><a href="#MetaObject创建流程" class="headerlink" title="MetaObject创建流程"></a>MetaObject创建流程</h2><p><img src="/images/mybatis_19.png" alt=""></p>
<h2 id="MetaObject"><a href="#MetaObject" class="headerlink" title="MetaObject"></a>MetaObject</h2><p><img src="/images/mybatis_20.png" alt=""></p>
<p>　　MetaObject作为reflection暴露在最外层的调用类，不仅承载了提供反射的各种实现调用的入口的责任，还担任了下层调用对象（ObjectWrapper包装者）的分发任务，MetaObject只有一个私有的构造方法，所以想创建MetaObject的实例只能通过MetaObject.forObject方法。</p>
<pre><code>public static MetaObject forObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    if (object == null) {
      return SystemMetaObject.NULL_META_OBJECT;
    } else {
      return new MetaObject(object, objectFactory, objectWrapperFactory, reflectorFactory);
    }
  }
private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    this.originalObject = object;
    this.objectFactory = objectFactory;
    this.objectWrapperFactory = objectWrapperFactory;
    this.reflectorFactory = reflectorFactory;

    //根据传入参数判断实例化哪种包装类
    if (object instanceof ObjectWrapper) {
      this.objectWrapper = (ObjectWrapper) object;
    } else if (objectWrapperFactory.hasWrapperFor(object)) {
      this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);
    } else if (object instanceof Map) {
      this.objectWrapper = new MapWrapper(this, (Map) object);
    } else if (object instanceof Collection) {
      this.objectWrapper = new CollectionWrapper(this, (Collection) object);
    } else {
      this.objectWrapper = new BeanWrapper(this, object);
    }
  }
</code></pre><p>　　既然MetaObject是以反射为基础，那么总重要的自然是getter和setter的实现，下面看一下MetaObject是如何操作属性的：</p>
<pre><code> public Object getValue(String name) {
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (prop.hasNext()) {
      //实例化指定次级属性的反射实例
      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());
      if (metaValue == SystemMetaObject.NULL_META_OBJECT) {
        //如果下级对象是null，则返回null。
        return null;
      } else {
        //如果传入的是多级参数名，则会依次向下直到获取最原始的被包装对象
        return metaValue.getValue(prop.getChildren());
      }
    } else {
      //获取指定属性
      return objectWrapper.get(prop);
    }
  }
public void setValue(String name, Object value) {
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (prop.hasNext()) {
      //如果传入的是多级参数名，则会依次向下直到获取最原始的被包装对象
      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());
      if (metaValue == SystemMetaObject.NULL_META_OBJECT) {
        //此包装类的上一层为NULL
        if (value == null &amp;&amp; prop.getChildren() != null) {
          //如果值为空且仍有下级对象，则不进行set
          return;
        } else {
          //实例化子级对象的元对象
          metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);
        }
      }
      //依次向下调用
      metaValue.setValue(prop.getChildren(), value);
    } else {
      //将属性放入指定对象
      objectWrapper.set(prop, value);
    }
  }
</code></pre><p>　　由上面代码可以看出，MetaObject作为一个反射入口，关键方法的抽象程度是很高的，在这一层也仅仅处理了对象这一层级的逻辑，凡事涉及具体属性的步骤都下放到ObjectWrapper中执行。</p>
<h2 id="ObjectWrapper"><a href="#ObjectWrapper" class="headerlink" title="ObjectWrapper"></a>ObjectWrapper</h2><p><img src="/images/mybatis_21.png" alt=""><br>　　上面的MetaObject将指定的属性定位到最后一级，然后就轮到ObjectWrapper出场了，ObjectWrapper主要的职责就是处理这个最后一级的类型，不仅支持简单属性的操作，还兼容集合类型的属性。</p>
<pre><code>public Object get(PropertyTokenizer prop) {
    if (prop.getIndex() != null) {
      //如果是子级对象是集合类型，则先取出集合对象
      Object collection = resolveCollection(prop, object);
      //从集合对象中取出对应属性的值
      return getCollectionValue(prop, collection);
    } else {
      //从bean对象中取出对应属性的值
      return getBeanProperty(prop, object);
    }
  }
public void set(PropertyTokenizer prop, Object value) {
    if (prop.getIndex() != null) {
      //如果是子级对象是集合类型，则先取出集合对象
      Object collection = resolveCollection(prop, object);
      //将值放入对象的指定key中
      setCollectionValue(prop, collection, value);
    } else {
      //为指定属性赋值
      setBeanProperty(prop, object, value);
    }
  }
/**
 * 实例化子级对象的元对象
 */
public MetaObject instantiatePropertyValue(String name, PropertyTokenizer prop, ObjectFactory objectFactory) {
    MetaObject metaValue;
    Class&lt;?&gt; type = getSetterType(prop.getName());
    try {
      //创建子级对象实例
      Object newObject = objectFactory.create(type);
      //创建实例的元对象实例
      metaValue = MetaObject.forObject(newObject, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(), metaObject.getReflectorFactory());
      //将子级对象放入父级对象中，类似user.setName()
      set(prop, newObject);
    } catch (Exception e) {
      throw new ReflectionException(&quot;Cannot set value of property &apos;&quot; + name + &quot;&apos; because &apos;&quot; + name + &quot;&apos; is null and cannot be instantiated on instance of &quot; + type.getName() + &quot;. Cause:&quot; + e.toString(), e);
    }
    return metaValue;
  }
private Object getBeanProperty(PropertyTokenizer prop, Object object) {
    try {
      //通过反射获取该属性的getter方法
      Invoker method = metaClass.getGetInvoker(prop.getName());
      try {
        return method.invoke(object, NO_ARGUMENTS);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    } catch (RuntimeException e) {
      throw e;
    } catch (Throwable t) {
      throw new ReflectionException(&quot;Could not get property &apos;&quot; + prop.getName() + &quot;&apos; from &quot; + object.getClass() + &quot;.  Cause: &quot; + t.toString(), t);
    }
  }
</code></pre><p>　　从这个方法可以看出，实际的操作是下放到MetaClass中的，而Invoker才是真正的反射调用器。</p>
<h2 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h2><p><img src="/images/mybatis_22.png" alt=""></p>
<p>　　MetaClass在我的理解里有些类似模板，MetaClass与MetaObject的关系类似于类与实例，MetaClass提供了类的各种属性方法的反射调用器，MetaObject提供了具体对象的引用，通过ObjectWrapper这个黑中介就联系到了一起。</p>
<pre><code>//获取name属性的getter调用器
public Invoker getGetInvoker(String name) {
    return reflector.getGetInvoker(name);
  }

//获取name属性的setter调用器
public Invoker getSetInvoker(String name) {
    return reflector.getSetInvoker(name);
  }
/**
 * 获取prop中一级属性的类型
 * @param prop
 * @return
 */
private Class&lt;?&gt; getGetterType(PropertyTokenizer prop) {
    Class&lt;?&gt; type = reflector.getGetterType(prop.getName());
    if (prop.getIndex() != null &amp;&amp; Collection.class.isAssignableFrom(type)) {
      //prop指定属性为实现了Collection接口的集合类型
      Type returnType = getGenericGetterType(prop.getName());
      if (returnType instanceof ParameterizedType) {
        Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();
        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 1) {
          returnType = actualTypeArguments[0];
          if (returnType instanceof Class) {
            type = (Class&lt;?&gt;) returnType;
          } else if (returnType instanceof ParameterizedType) {
            type = (Class&lt;?&gt;) ((ParameterizedType) returnType).getRawType();
          }
        }
      }
    }
    return type;
  }
/**
 * 查询是否存在name属性的setter方法
 * @param name
 * @return
 */
public boolean hasSetter(String name) {
    PropertyTokenizer prop = new PropertyTokenizer(name);
    if (prop.hasNext()) {
      //如果是多级属性，会依次向下递归，查询指定的最底层属性的setter方法
      if (reflector.hasSetter(prop.getName())) {
        MetaClass metaProp = metaClassForProperty(prop.getName());
        return metaProp.hasSetter(prop.getChildren());
      } else {
        return false;
      }
    } else {
      return reflector.hasSetter(prop.getName());
    }
  }
</code></pre><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><p>　　Reflector是整个反射模块的核心，是维护Invoker的容器，所有的反射操作都会放到Reflector来进行调度。下面看下Reflector的初始化流程：</p>
<pre><code>//反射容器对应的类
private Class&lt;?&gt; type;
//setter方法调用器缓存
private Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;String, Invoker&gt;();
//getter方法调用器缓存
private Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;String, Invoker&gt;();
//setter方法对应属性类型缓存
private Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;String, Class&lt;?&gt;&gt;();
//getter方法对应属性类型缓存
private Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;String, Class&lt;?&gt;&gt;();
//默认构造器
private Constructor&lt;?&gt; defaultConstructor;
//全大写属性名集合，为了兼容传入参数的大小写
private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;String, String&gt;();

public Reflector(Class&lt;?&gt; clazz) {
    type = clazz;
    //注册默认构造器
    addDefaultConstructor(clazz);
    //注册getter方法
    addGetMethods(clazz);
    //注册setter方法
    addSetMethods(clazz);
    //注册属性
    addFields(clazz);
    //可读属性名集合
    readablePropertyNames = getMethods.keySet().toArray(new String[getMethods.keySet().size()]);
    //可写属性名集合
    writeablePropertyNames = setMethods.keySet().toArray(new String[setMethods.keySet().size()]);
    //将属性名改为大写，为做大小写兼容做准备
    for (String propName : readablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    for (String propName : writeablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
  }
/**
 * 注册无参构造方法
 */
private void addDefaultConstructor(Class&lt;?&gt; clazz) {
    //获取clazz的所有构造器
    Constructor&lt;?&gt;[] consts = clazz.getDeclaredConstructors();
    for (Constructor&lt;?&gt; constructor : consts) {
      if (constructor.getParameterTypes().length == 0) {
        //无参构造方法
        if (canAccessPrivateMethods()) {
          try {
            //关闭java安全检查，提高反射性能
            constructor.setAccessible(true);
          } catch (Exception e) {
          }
        }
        //上边取消了无参构造方法的安全检查，此处将其赋值给defaultConstructor
        if (constructor.isAccessible()) {
          this.defaultConstructor = constructor;
        }
      }
    }
  }
/**
 * 注册getter方法
 * @param cls
 */
 private void addGetMethods(Class&lt;?&gt; cls) {
    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;String, List&lt;Method&gt;&gt;();
    //获取cls中的所有方法，包括父类和接口中的方法
    Method[] methods = getClassMethods(cls);
    for (Method method : methods) {
      //getter方法不应包含参数
      if (method.getParameterTypes().length &gt; 0) {
        continue;
      }
      String name = method.getName();
      //判断方法名是否符合get或者布尔值get命名
      if ((name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3)
          || (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2)) {
        name = PropertyNamer.methodToProperty(name);
        //将get方法实例添加至conflictingGetters
        addMethodConflict(conflictingGetters, name, method);
      }
    }
    resolveGetterConflicts(conflictingGetters);
  }
/**
 * 过滤掉同一名称的getter方法，返回值为同一继承树的类型以子类型为主
 * @param conflictingGetters
 */
private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {
    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {
      Method winner = null;
      String propName = entry.getKey();
      for (Method candidate : entry.getValue()) {
        if (winner == null) {
          winner = candidate;
          continue;
        }
        Class&lt;?&gt; winnerType = winner.getReturnType();
        Class&lt;?&gt; candidateType = candidate.getReturnType();
        //因为方法对应属性名相同（不论前缀是is或get），所以如果两者返回值类型相同时必为布尔类型（非布尔类型默认不使用is前缀）。
        if (candidateType.equals(winnerType)) {
          if (!boolean.class.equals(candidateType)) {
            throw new ReflectionException(
                &quot;Illegal overloaded getter method with ambiguous type for property &quot;
                    + propName + &quot; in class &quot; + winner.getDeclaringClass()
                    + &quot;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;);
          } else if (candidate.getName().startsWith(&quot;is&quot;)) {
            winner = candidate;
          }
        } else if (candidateType.isAssignableFrom(winnerType)) {
          // OK getter type is descendant
        } else if (winnerType.isAssignableFrom(candidateType)) {
          //winnerType是candidateType的父类或接口或两者相同，此时以子类类型为主。
          winner = candidate;
        } else {
          throw new ReflectionException(
              &quot;Illegal overloaded getter method with ambiguous type for property &quot;
                  + propName + &quot; in class &quot; + winner.getDeclaringClass()
                  + &quot;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;);
        }
      }
      //将method及返回类型添加至缓存区
      addGetMethod(propName, winner);
    }
  }
/**
 * 注册setter方法
 * @param cls
 */
private void addSetMethods(Class&lt;?&gt; cls) {
    Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters = new HashMap&lt;String, List&lt;Method&gt;&gt;();
    Method[] methods = getClassMethods(cls);
    for (Method method : methods) {
      String name = method.getName();
      if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {
        if (method.getParameterTypes().length == 1) {
          //以set开头且只有一个参数的判定为setter方法
          name = PropertyNamer.methodToProperty(name);
          //将set方法实例添加至conflictingSetters
          addMethodConflict(conflictingSetters, name, method);
        }
      }
    }
    resolveSetterConflicts(conflictingSetters);
  }
/**
 * 将method添加值conflictingMethods集合,可以支持同一属性多个方法
 * @param conflictingMethods
 * @param name
 * @param method
 */
private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {
    List&lt;Method&gt; list = conflictingMethods.get(name);
    if (list == null) {
      list = new ArrayList&lt;Method&gt;();
      conflictingMethods.put(name, list);
    }
    list.add(method);
  }
/**
 * 过滤掉同一名称的setter方法，返回值为同一继承树的类型以子类型为主
 * @param conflictingGetters
 */
private void resolveSetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters) {
    for (String propName : conflictingSetters.keySet()) {
      List&lt;Method&gt; setters = conflictingSetters.get(propName);
      //从缓存集合中获取propName属性对应的get类型
      Class&lt;?&gt; getterType = getTypes.get(propName);
      Method match = null;
      ReflectionException exception = null;
      for (Method setter : setters) {
        Class&lt;?&gt; paramType = setter.getParameterTypes()[0];
        if (paramType.equals(getterType)) {
          // should be the best match
          match = setter;
          break;
        }
        if (exception == null) {
          try {
            //取match与setter中返回类型为子类的方法
            match = pickBetterSetter(match, setter, propName);
          } catch (ReflectionException e) {
            match = null;
            exception = e;
          }
        }
      }
      if (match == null) {
        throw exception;
      } else {
        //将propName的set方法和set类型放入缓存
        addSetMethod(propName, match);
      }
    }
  }
/**
 * 注册属性
 * @param clazz
 */
private void addFields(Class&lt;?&gt; clazz) {
    Field[] fields = clazz.getDeclaredFields();
    for (Field field : fields) {
      //检查是否能够访问类中的字段和调用方法。注意，这不仅包括 public. 而且还包括 protected 和 private 字段和方法。
      if (canAccessPrivateMethods()) {
        try {
          //关闭属性的安全检查
          field.setAccessible(true);
        } catch (Exception e) {
        }
      }
      if (field.isAccessible()) {
        //检查缓存中是否包含field的get. set方法，如果没有则创建新的get. set方法放入缓存区
        if (!setMethods.containsKey(field.getName())) {
          int modifiers = field.getModifiers();
          //同时使用static和final修饰的变量不能使用反射获取
          if (!(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers))) {
            addSetField(field);
          }
        }
        if (!getMethods.containsKey(field.getName())) {
          addGetField(field);
        }
      }
    }
    if (clazz.getSuperclass() != null) {
      //注册父类的属性
      addFields(clazz.getSuperclass());
    }
  }
</code></pre><h2 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h2><p>作为具体的反射操作调用器，Invoker提供了三种默认实现。</p>
<ul>
<li>GetFieldInvoker：属性get方法调用器</li>
</ul>
<pre><code>public Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException {
    return field.get(target);
  }
</code></pre><ul>
<li>SetFieldInvoker：属性set方法调用器</li>
</ul>
<pre><code>public Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException {
    field.set(target, args[0]);
    return null;
  }
</code></pre><ul>
<li>MethodInvoker：方法调用器</li>
</ul>
<pre><code>public MethodInvoker(Method method) {
    this.method = method;
    //此处设置类型是为了方便get. set方法
    if (method.getParameterTypes().length == 1) {
      type = method.getParameterTypes()[0];
    } else {
      type = method.getReturnType();
    }
  }
public Object invoke(Object target, Object[] args) throws IllegalAccessException, InvocationTargetException {
    return method.invoke(target, args);
  }
</code></pre><h2 id="PropertyTokenizer"><a href="#PropertyTokenizer" class="headerlink" title="PropertyTokenizer"></a>PropertyTokenizer</h2><p>　　PropertyTokenizer负责处理传入的属性名字符串，这里不仅支持单级，还支持多级和集合类型的属性名。</p>
<pre><code>public PropertyTokenizer(String fullname) {
    int delim = fullname.indexOf(&apos;.&apos;);
    if (delim &gt; -1) {
      //如果传入的是多级属性名，则name为一级属性，children为次级属性
      name = fullname.substring(0, delim);
      children = fullname.substring(delim + 1);
    } else {
      //如果传入的是单级属性，name为属性名
      name = fullname;
      children = null;
    }
    //此处先备份name为了处理属性类型为集合的情况
    indexedName = name;
    delim = name.indexOf(&apos;[&apos;);
    if (delim &gt; -1) {
      //如果name代表的属性为集合类型，MyBatis默认用[]表示，如user.books[math]
      //index表示集合中的指定属性名
      index = name.substring(delim + 1, name.length() - 1);
      //name表示集合名
      name = name.substring(0, delim);
    }
  }
</code></pre><h2 id="PropertyNamer"><a href="#PropertyNamer" class="headerlink" title="PropertyNamer"></a>PropertyNamer</h2><p>　　PropertyNamer通过方法名获取对应属性名，仅支持get. set. is开头的方法</p>
<pre><code>/**
 * 通过方法名获取对应的属性名，只支持get. set和is开头的方法
 * @param name
 * @return
 */
public static String methodToProperty(String name) {
    if (name.startsWith(&quot;is&quot;)) {
      name = name.substring(2);
    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
      name = name.substring(3);
    } else {
      throw new ReflectionException(&quot;Error parsing property name &apos;&quot; + name + &quot;&apos;.  Didn&apos;t start with &apos;is&apos;, &apos;get&apos; or &apos;set&apos;.&quot;);
    }
    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {
      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);
    }
    return name;
  }
</code></pre><h2 id="为什么使用MetaObject"><a href="#为什么使用MetaObject" class="headerlink" title="为什么使用MetaObject"></a>为什么使用MetaObject</h2><p>　　MetaObject提供了方便而优雅的方式来操作对象的属性，不仅不需要手动处理各种reflect异常，还可以无视变量的作用域。</p>
<p>　　MetaObject还支持Map和Connection形式的对象，不过相对javaBean来讲简单很多，此处不在赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：数据源和连接池]]></title>
      <url>/2017/06/15/mybatis-9/</url>
      <content type="html"><![CDATA[<p>　　MyBatis是一种ORM框架，作为关系映射一端的数据源自然是重中之重了，下面就简单介绍下MyBatis的数据源模块。</p>
<h2 id="DataSource的三种类型"><a href="#DataSource的三种类型" class="headerlink" title="DataSource的三种类型"></a>DataSource的三种类型</h2><p>　　MyBatis中默认有三种DataSource实现，分别是不使用连接池的UnpooledDataSource、使用连接池的PooledDataSource和使用JNDI的JndiDataSource。<br><a id="more"></a></p>
<h2 id="DataSource的创建过程"><a href="#DataSource的创建过程" class="headerlink" title="DataSource的创建过程"></a>DataSource的创建过程</h2><p><img src="/images/mybatis_14.png" alt=""></p>
<h3 id="在config-xml中配置environments标签"><a href="#在config-xml中配置environments标签" class="headerlink" title="在config.xml中配置environments标签"></a>在config.xml中配置environments标签</h3><pre><code>&lt;environments default=&quot;development1&quot;&gt;
     &lt;environment id=&quot;development1&quot;&gt;
         &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
         &lt;dataSource type=&quot;UNPOOLED&quot;&gt;
             &lt;property name=&quot;driver&quot; value=&quot;${driver1}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${url1}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${username1}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${password1}&quot;/&gt;
         &lt;/dataSource&gt;
     &lt;/environment&gt;
&lt;/environments&gt;
</code></pre><h3 id="创建SqlSessionFactory"><a href="#创建SqlSessionFactory" class="headerlink" title="创建SqlSessionFactory"></a>创建SqlSessionFactory</h3><pre><code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,&quot;development1&quot;);
</code></pre><h3 id="构造Configuration实例"><a href="#构造Configuration实例" class="headerlink" title="构造Configuration实例"></a>构造Configuration实例</h3><pre><code>public Configuration parse() {
    if (parsed) {
      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
    }
    parsed = true;
    //获取config.xml配置文件中的内容，进行组装
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
  }
</code></pre><h3 id="读取environments标签"><a href="#读取environments标签" class="headerlink" title="读取environments标签"></a>读取environments标签</h3><pre><code>private void environmentsElement(XNode context) throws Exception {
    if (context != null) {
      //如果构建SqlSessionFactory时传入了environment参数，则使用指定数据源，否则使用配置的默认数据源
      if (environment == null) {
        environment = context.getStringAttribute(&quot;default&quot;);
      }
      //遍历所有配置的environment数据，搜索id与指定数据源匹配的元素
      for (XNode child : context.getChildren()) {
        String id = child.getStringAttribute(&quot;id&quot;);
        if (isSpecifiedEnvironment(id)) {
          //事务管理器工厂
          TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));
          //数据源工厂
          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));
          DataSource dataSource = dsFactory.getDataSource();
          //数据交互环境构造器
          Environment.Builder environmentBuilder = new Environment.Builder(id)
              .transactionFactory(txFactory)
              .dataSource(dataSource);
          //将数据源放入configuration上下文中
          configuration.setEnvironment(environmentBuilder.build());
        }
      }
    }
  }
</code></pre><h2 id="不使用连接池的DataSource"><a href="#不使用连接池的DataSource" class="headerlink" title="不使用连接池的DataSource"></a>不使用连接池的DataSource</h2><p><img src="/images/mybatis_15.png" alt=""></p>
<p>UnpooledDataSource相对PooledDataSource简单一点，每次调用都创建一个数据库连接，执行之后连接即可销毁。相关类主要有以下两个</p>
<h3 id="UnpooledDataSourceFactory"><a href="#UnpooledDataSourceFactory" class="headerlink" title="UnpooledDataSourceFactory"></a>UnpooledDataSourceFactory</h3><p>只有两个方法setProperties和getDataSource，一个设置数据源参数，一个获取数据源。</p>
<h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><p>既然是数据源，那最重要也就是获取数据库连接的方法了，下面看下获取数据库连接的方法：</p>
<pre><code>private Connection doGetConnection(Properties properties) throws SQLException {
    //初始化数据库驱动，如果environment中的driver属性配置的数据库驱动没有初始化，则会通过反射加载指定驱动
    initializeDriver();
    //获取数据库连接
    Connection connection = DriverManager.getConnection(url, properties);
    //配置连接是否自动提交，隔离等级
    configureConnection(connection);
    return connection;
  }
</code></pre><h2 id="使用连接池的DataSource"><a href="#使用连接池的DataSource" class="headerlink" title="使用连接池的DataSource"></a>使用连接池的DataSource</h2><p><img src="/images/mybatis_16.png" alt=""></p>
<p>　　PooledDataSource从源码角度来看实际是在UnpooledDataSource架子上做了一些扩展，在PooledDataSource维护了一个UnpooledDataSource实例，获取数据库连接的依然是UnpooledDataSource的那一套方法，不过既然要使用连接池自然不会如此简单，这就涉及到了PoolState和PooledConnection这两个类。</p>
<h3 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h3><p>PoolState是连接池的状态上下文，内部维护了很多运行时的状态数据，其中只有两个参与了连接池的操作，(空闲连接队列)idleConnections和(活跃连接队列)activeConnections。</p>
<h3 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h3><p>数据库连接的代理类，说到代理类，那自然就有invoke方法了：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    String methodName = method.getName();
    //当执行close方法时，不会真的关闭连接，会根据连接池的状态决定如何处理
    if (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) {
      dataSource.pushConnection(this);
      return null;
    } else {
      try {
        if (!Object.class.equals(method.getDeclaringClass())) {
          //检查连接是否可用
          checkConnection();
        }
        return method.invoke(realConnection, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
  }
</code></pre><p>有上面源码可知，其实代理主要是为了处理close方法，毕竟连接池中的连接是需要重用的，不然岂不是和不用连接池一样了。</p>
<h3 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><pre><code>//连接池状态上下文
private final PoolState state = new PoolState(this);
//实际获取数据库连接的数据源
private final UnpooledDataSource dataSource;
//最大活跃连接数
protected int poolMaximumActiveConnections = 10;
//最大空闲连接数
protected int poolMaximumIdleConnections = 5;
//如果一次调用超过此时间，则会强制结束调用
protected int poolMaximumCheckoutTime = 20000;
//再次尝试连接的等待时间
protected int poolTimeToWait = 20000;
//心跳检测
protected String poolPingQuery = &quot;NO PING QUERY SET&quot;;
//是否使用心跳检测
protected boolean poolPingEnabled;
//如果一个连接超过此时间没有被使用，尝试ping这个数据源查看是否可用
protected int poolPingConnectionsNotUsedFor;
//连接的唯一code码
private int expectedConnectionTypeCode;

/**
 * 强制关闭所有连接，修改连接池参数或数据源参数时调用
 */
public void forceCloseAll() {
  //因为活跃连接和空闲连接的集合是在PoolState中维护，所以强制关闭时需要锁定state
  synchronized (state) {
    //强制关闭所有连接的触发点包括更改数据源信息，所以此处要重新赋值code
    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());
    //关闭所有活跃连接
    for (int i = state.activeConnections.size(); i &gt; 0; i--) {
      try {
        PooledConnection conn = state.activeConnections.remove(i - 1);
        //连接状态修改为不可用
        conn.invalidate();
        //因为PooledConnection实际上是Connection的代理类，所以关闭的时候需要获取JDBC的连接进行关闭。
        Connection realConn = conn.getRealConnection();
        if (!realConn.getAutoCommit()) {
          realConn.rollback();
        }
        realConn.close();
      } catch (Exception e) {
      }
    }
    //关闭所有空闲连接
    for (int i = state.idleConnections.size(); i &gt; 0; i--) {
      try {
        PooledConnection conn = state.idleConnections.remove(i - 1);
        //连接状态修改为不可用
        conn.invalidate();
        //因为PooledConnection实际上是Connection的代理类，所以关闭的时候需要获取JDBC的连接进行关闭。
        Connection realConn = conn.getRealConnection();
        if (!realConn.getAutoCommit()) {
          realConn.rollback();
        }
        realConn.close();
      } catch (Exception e) {
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(&quot;PooledDataSource forcefully closed/removed all connections.&quot;);
  }
}
</code></pre><p>　　通常情况下，当我们使用完一个连接时，会调用close方法释放连接，避免影响性能，连接池中的连接代理实例调用close方法时实际上不会简单的释放掉连接，而是调用pushConnection方法将连接放入空闲队列，等待下次调用。</p>
<pre><code>  protected void pushConnection(PooledConnection conn) throws SQLException {
    synchronized (state) {
      //从活跃连接队列中清除
      state.activeConnections.remove(conn);
      //连接是可用状态
      if (conn.isValid()) {
        //当前空闲连接数小于设置的最大空闲连接数且此连接的数据源与连接池相同
        if (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) {
          state.accumulatedCheckoutTime += conn.getCheckoutTime();
          //如果连接设置手动提交，则回滚修改的内容，防止强制关闭引起数据错误
          if (!conn.getRealConnection().getAutoCommit()) {
            conn.getRealConnection().rollback();
          }
          //创建新的代理类，并放入空闲连接队列
          PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);
          state.idleConnections.add(newConn);
          newConn.setCreatedTimestamp(conn.getCreatedTimestamp());
          newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());
          //废弃连接代理设置为不可用
          conn.invalidate();
          if (log.isDebugEnabled()) {
            log.debug(&quot;Returned connection &quot; + newConn.getRealHashCode() + &quot; to pool.&quot;);
          }
          state.notifyAll();
        } else {
          state.accumulatedCheckoutTime += conn.getCheckoutTime();
          //如果连接设置手动提交，则回滚修改的内容，防止强制关闭引起数据错误
          if (!conn.getRealConnection().getAutoCommit()) {
            conn.getRealConnection().rollback();
          }
          //关闭连接
          conn.getRealConnection().close();
          if (log.isDebugEnabled()) {
            log.debug(&quot;Closed connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
          }
          //废弃连接代理设置为不可用
          conn.invalidate();
        }
      } else {
        if (log.isDebugEnabled()) {
          log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) attempted to return to the pool, discarding connection.&quot;);
        }
        state.badConnectionCount++;
      }
    }
  }

/**
 * 获取连接
 */
private PooledConnection popConnection(String username, String password) throws SQLException {
    boolean countedWait = false;
    PooledConnection conn = null;
    long t = System.currentTimeMillis();
    int localBadConnectionCount = 0;

    while (conn == null) {
      synchronized (state) {
        if (!state.idleConnections.isEmpty()) {
          //存在空闲连接时，取队列中的第一个空闲连接
          conn = state.idleConnections.remove(0);
          if (log.isDebugEnabled()) {
            log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);
          }
        } else {
          //连接池中不存在空闲连接时
          //当连接池中的活跃连接小于最大的活跃连接数时
          if (state.activeConnections.size() &lt; poolMaximumActiveConnections) {
            //创建新的连接代理实例
            conn = new PooledConnection(dataSource.getConnection(), this);
            if (log.isDebugEnabled()) {
              log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
            }
          } else {
            //当连接池中的活跃连接达到阈值时，不能创建新连接
            //获取活跃连接队列中执行时间最长的实例（FIFO）
            PooledConnection oldestActiveConnection = state.activeConnections.get(0);
            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();
            if (longestCheckoutTime &gt; poolMaximumCheckoutTime) {
              //此连接的checkout时间已经超过了设置的最长checkout时间，此时可以将此连接当前操作作废，移出活跃队列
              state.claimedOverdueConnectionCount++;
              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;
              state.accumulatedCheckoutTime += longestCheckoutTime;
              state.activeConnections.remove(oldestActiveConnection);
              //将连接当前操作回滚，防止数据错误
              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {
                try {
                  oldestActiveConnection.getRealConnection().rollback();
                } catch (SQLException e) {
                  log.debug(&quot;Bad connection. Could not roll back&quot;);
                }  
              }
              //创建新的连接代理实例
              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);
              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());
              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());
              //修改旧代理类为不可用
              oldestActiveConnection.invalidate();
              if (log.isDebugEnabled()) {
                log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
              }
            } else {
              //当不能创建新连接，活跃连接中也没有超过过期时间的连接时，只能等待了=。=
              try {
                if (!countedWait) {
                  state.hadToWaitCount++;
                  countedWait = true;
                }
                if (log.isDebugEnabled()) {
                  log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);
                }
                long wt = System.currentTimeMillis();
                //默认的等待时间和连接过期时间一样是20s，所以如果不做修改的话，20s之后必然会有连接可用，如果短时间内爆发超过处理能力数倍的并发请求的话，就不是能在这里处理的了
                state.wait(poolTimeToWait);
                state.accumulatedWaitTime += System.currentTimeMillis() - wt;
              } catch (InterruptedException e) {
                break;
              }
            }
          }
        }
        if (conn != null) {
          if (conn.isValid()) {
            //当获取的连接可用时，首先将连接rollback，防止有未提交操作
            if (!conn.getRealConnection().getAutoCommit()) {
              conn.getRealConnection().rollback();
            }
            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));
            conn.setCheckoutTimestamp(System.currentTimeMillis());
            conn.setLastUsedTimestamp(System.currentTimeMillis());
            //将连接放入活跃队列
            state.activeConnections.add(conn);
            state.requestCount++;
            state.accumulatedRequestTime += System.currentTimeMillis() - t;
          } else {
            //当获取的连接不可用时，增加一个损坏连接数，如果损坏连接数达到阈值，则抛出异常
            if (log.isDebugEnabled()) {
              log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;);
            }
            state.badConnectionCount++;
            localBadConnectionCount++;
            conn = null;
            if (localBadConnectionCount &gt; (poolMaximumIdleConnections + 3)) {
              if (log.isDebugEnabled()) {
                log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);
              }
              throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);
            }
          }
        }
      }
    }

    if (conn == null) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);
      }
      throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);
    }

    return conn;
  }

/**
   * 检查连接是否可用
   * @param conn - the connection to check
   * @return True if the connection is still usable
   */
  protected boolean pingConnection(PooledConnection conn) {
    boolean result = true;

    try {
      //1、校验连接是否已关闭
      result = !conn.getRealConnection().isClosed();
    } catch (SQLException e) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());
      }
      result = false;
    }

    if (result) {
      //开启心跳测试
      if (poolPingEnabled) {
        //连接的空闲时间超过心跳测试的触发时间
        if (poolPingConnectionsNotUsedFor &gt;= 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) {
          try {
            if (log.isDebugEnabled()) {
              log.debug(&quot;Testing connection &quot; + conn.getRealHashCode() + &quot; ...&quot;);
            }
            //尝试执行心跳测试
            Connection realConn = conn.getRealConnection();
            Statement statement = realConn.createStatement();
            ResultSet rs = statement.executeQuery(poolPingQuery);
            rs.close();
            statement.close();
            if (!realConn.getAutoCommit()) {
              realConn.rollback();
            }
            result = true;
            if (log.isDebugEnabled()) {
              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is GOOD!&quot;);
            }
          } catch (Exception e) {
            log.warn(&quot;Execution of ping query &apos;&quot; + poolPingQuery + &quot;&apos; failed: &quot; + e.getMessage());
            try {
              conn.getRealConnection().close();
            } catch (Exception e2) {
            }
            result = false;
            if (log.isDebugEnabled()) {
              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());
            }
          }
        }
      }
    }
    return result;
  }
</code></pre><h2 id="使用连接池有什么好处"><a href="#使用连接池有什么好处" class="headerlink" title="使用连接池有什么好处"></a>使用连接池有什么好处</h2><p>　　首先我们来看一下创建连接的性能消耗。</p>
<pre><code>try {
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    String url = &quot;jdbc:mysql://192.168.1.39:3306/dlb&quot;;
    long createConnectionTime = System.currentTimeMillis();
    Connection conn = DriverManager.getConnection(url,&quot;ymt&quot;,&quot;yimiaotong2015&quot;);
    System.out.println(&quot;创建连接消耗的时间：&quot;+(System.currentTimeMillis() - createConnectionTime));

    long executeTime = System.currentTimeMillis();
    PreparedStatement ps = conn.prepareStatement(&quot;select phoneNO from users where id = 1&quot;);
    ResultSet rs = ps.executeQuery();
    System.out.println(&quot;执行sql消耗时间：&quot;+(System.currentTimeMillis() - executeTime));

} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}
</code></pre><p><img src="/images/mybatis_17.png" alt=""></p>
<p>创建一个连接需要178ms，如果请求量上来了，那画面太美。恰巧还是一个“不谙世事”的程序员，天天追着老板买新服务器，估计老板砍死你的心都有了。笑<br>连接池中的连接在执行sql操作之后不会进行close，而是调用pushConnection进行调度，将连接在活跃和空闲队列中来回流转，等待执行任务，这样就节约了每次都要创建连接的开销。</p>
<h2 id="何时创建Connection"><a href="#何时创建Connection" class="headerlink" title="何时创建Connection"></a>何时创建Connection</h2><p>　　当我们需要执行一个sql语句时，Executor会调用getConnection方法创建一个Connection。</p>
<pre><code>protected Connection getConnection(Log statementLog) throws SQLException {
    Connection connection = transaction.getConnection();
    if (statementLog.isDebugEnabled()) {
      return ConnectionLogger.newInstance(connection, statementLog, queryStack);
    } else {
      return connection;
    }
  }
public Connection getConnection() throws SQLException {
    if (connection == null) {
      openConnection();
    }
    return connection;
  }
</code></pre><h2 id="JNDI类型DataSource"><a href="#JNDI类型DataSource" class="headerlink" title="JNDI类型DataSource"></a>JNDI类型DataSource</h2><p>　　MyBatis定义了一个JndiDataSourceFactory来创建JDNI形式的数据源，具体配置参考各容器的文档。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：Mybatis的缓存机制]]></title>
      <url>/2017/06/15/mybatis-8/</url>
      <content type="html"><![CDATA[<p>　　俗话说不搞缓存的ORM不是好框架（笑），咱大MyBatis自然也不能免俗了，这就提供了一级缓存和二级缓存来应个景。</p>
<h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><p>　　在实际的业务场景里，通常查询操作比修改操作多很多，当并发量很大的时候就会让服务器不堪重负，但是老板又不给批款购买新机器，这可怎么办呢？只能发挥程序员的奇思妙想提升程序的性能了，既然与数据库的会话会消耗很多性能，那就将使用最多的查询功能提取出来，将常用查询语句的结果放在内存中缓存，这样每次先在内存中查询是否有缓存数据，如果没有才会创建一个数据库会话，是不是就快很多了。但是这也有一个新的问题，就是缓存的命中率，如果架构设计的时候设计不当，导致常用的语句没设置缓存，不常用的却设置了缓存，反而会降低系统性能。<br><a id="more"></a></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>　　MyBatis的缓存基础是PerpetualCache，PerpetualCache实现了Cache接口，内部其实是维护了一个HashMap对象进行数据的缓存，下面看下Cache的家族树：<br><img src="/images/mybatis_9.png" alt=""></p>
<p>乍一看哎呦喂，挺多实现类啊，其实这里使用了装饰者模式，其他的实现类都是装饰了PerpetualCache类。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>　　MyBatis的一级缓存默认就是开启的（想关都关不掉），我们能做的就是设置一下他的生命周期，配置如下：</p>
<pre><code>&lt;settings&gt;
     &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION|STATEMENT&quot; /&gt;
 &lt;/settings&gt;
</code></pre><p>如果配置为Session，就是以一次数据库会话为周期，在实际开发中通常一次请求只创建一次会话，所以也可以理解为以一次请求为周期的缓存。<br>如果配置为Statement，则仅作用于语句的执行上，不会影响同一会话的其他调用。</p>
<p>下面我们来看下MyBatis的一级缓存是如何工作的：<br><img src="/images/mybatis_10.png" alt=""></p>
<p>首先创建一个新的数据库会话，此时会实例化一个Executor</p>
<pre><code>//实例化Executor执行器
final Executor executor = configuration.newExecutor(tx, execType);
在BaseExecutor维护了一个PerpetualCache，这个就是所说的一级缓存（也叫本地缓存）了
//一级缓存（本地缓存）
protected PerpetualCache localCache;
在查询的时候会首先在这个一级缓存中查询是否有值
list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
if (list != null) {
     //缓存中存在结果集时
     handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
} else {
     //从数据库获取数据，此处会将结果保存在localCache中
     list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
}
</code></pre><p>　　正确的使用缓存确实能提高不少性能，但是这里就引出了一个新问题，如果我缓存的数据过期了怎么办？对于一些时效性不强的模块中有一些脏数据或许不会影响使用，但是对于要求数据时效性很强的系统中就不能这么玩了，所以MyBatis提供了手动配置刷新时机的方法。</p>
<p>一共有四个触发方法会刷新一级缓存：</p>
<ul>
<li>commit</li>
<li>rollback</li>
<li>update</li>
<li>query（如果配置了flushCache属性为true或localCacheScope设置为Statement）</li>
</ul>
<p>只有query中的两个触发点是需要手动配置，其余三个都会自动清空一级缓存区。<br><img src="/images/mybatis_11.png" alt=""><br><img src="/images/mybatis_12.png" alt=""></p>
<p>　　既然是大量操作的时候才会用到缓存，那么缓存的数据量想必是很大的，如何确定每次操作要请求的缓存数据对象就是一个问题了，在MyBatis中有一个叫做cacheKey的东西，这个就是用来确定缓存唯一性的key了，下面看一下生成cacheKey的方法：</p>
<pre><code>public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    CacheKey cacheKey = new CacheKey();
    cacheKey.update(ms.getId());
    cacheKey.update(rowBounds.getOffset());
    cacheKey.update(rowBounds.getLimit());
    cacheKey.update(boundSql.getSql());
    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    // mimic DefaultParameterHandler logic
    for (ParameterMapping parameterMapping : parameterMappings) {
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        String propertyName = parameterMapping.getProperty();
        if (boundSql.hasAdditionalParameter(propertyName)) {
          value = boundSql.getAdditionalParameter(propertyName);
        } else if (parameterObject == null) {
          value = null;
        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        cacheKey.update(value);
      }
    }
    if (configuration.getEnvironment() != null) {
      // issue #176
      cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
  }
</code></pre><p>这里不难看出实际上MyBatis采用的是符合型key值，key的组合值有以下六项：</p>
<ul>
<li>MappedStatementID</li>
<li>offset</li>
<li>limit</li>
<li>sql</li>
<li>param value</li>
<li>environmentID</li>
</ul>
<p>通过这六个组合参数可以看出MyBatis对于相同查询的定义：</p>
<ul>
<li>MappedStatementID必须相同，在构建Configuration时会为每个mapper方法创建一个唯一MappedStatement，所以这是第一个约束。</li>
<li>查询范围必须相同，RowBounds中的offset和limit共同约束了本次查询的范围。这种分页是基于查询结果进行再次过滤，并不是数据库的物理分页。</li>
<li>传递给JDBC的sql必须相同（BoundSql.getSql()）。由于MyBatis底层也是依赖于JDBC实现，对于JDBC来说只要传入的sql和参数相同就视为相同查询。</li>
<li>查询语句的参数必须相同，这里有一个盲点，参数相同指的是sql有用到的参数必须相同，比如传入一个user对象，如果sql没有用到user.name这个属性，那么不论name的值是否相同都不会影响判断。</li>
<li>数据源必须相同，这个就不用说了。</li>
</ul>
<p>一级缓存本质上是维护了一个HashMap，那么作为key的CacheKey就需要有一个统一的hash算法进行支持了，下面看下CacheKey的核心算法:</p>
<pre><code>public void update(Object object) {
    if (object != null &amp;&amp; object.getClass().isArray()) {
      int length = Array.getLength(object);
      for (int i = 0; i &lt; length; i++) {
        Object element = Array.get(object, i);
        doUpdate(element);
      }
    } else {
      doUpdate(object);
    }
  }
  private void doUpdate(Object object) {
    //得到对象的hashCode
    int baseHashCode = object == null ? 1 : object.hashCode();
    //计数器+1
    count++;
    //累加CacheKey组合参数的hashCode
    checksum += baseHashCode;
    //扩大对象的hashCode为count倍
    baseHashCode *= count;
    //CacheKey的hashCode变为原hashCode*扩展系数（默认37）+此对象的hashCode
    hashcode = multiplier * hashcode + baseHashCode;
    updateList.add(object);
  }
</code></pre><p>　　说了这么多，那么一级缓存的性能如何呢？<br>　　从空间角度来看，一级缓存只是简单的使用的HashMap进行维护，并且没有对Has和Map的容量进行限制，这时候可能就有小伙伴会问了，这岂不是会占用很多内存吗，哪个渣渣写的代码，拖出去斩了=。=。MyBatis确实没在空间方面做硬性限制，但是呢在操作方式上其实还是有软限制的，一级缓存的生存周期是一个SqlSession会话，通常情况下每个request会新建一个SqlSession，一个request能执行多长时间（如果您的项目对SqlSession使用单例实现，请默默点击右上角的叉叉，笑），而且呢就算是这个SqlSession生活节奏比较慢，就是拖着不让回收也没问题，每次执行update操作的时候MyBatis会清空一次一级缓存，更极端点就算是这个死拖着不走的SqlSession全是查询操作，不还是可以手动清理缓存区的么（笑）。<br>从时间的角度看，MyBatis的一级缓存是粗粒度的，没有缓存过期的概念，也就是不会主动请求数据源对缓存进行更新，<br>由上面两点来看呢，一级缓存的一点不泛用性就展现出来了，对于数据变化的频率高，且对数据时效性要求高的业务来说就要控制每个SqlSession的生存时间了，时间越长缓存中的数据的准确性就越低了。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>　　一级缓存是在一个SqlSession会话的周期内有效，那么不同的SqlSession想一起玩怎么办呢，这时候就用到了二级缓存。<br><img src="/images/mybatis_13.png" alt=""></p>
<p>　　二级缓存简单来说就是在Configuration中维护的一个HashMap集合，MyBatis默认使用的和一级缓存一样是PerpetualCache这个实现（只不过使用TransactionalCache装饰了一下），与一级缓存不同，二级缓存是需要手动开启的，要使用二级缓存需要以下两个步骤：</p>
<ul>
<li>配置config.xml：</li>
</ul>
<pre><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre><ul>
<li>配置mapper.xml：</li>
</ul>
<pre><code>&lt;cache&gt;&lt;/cache&gt;&lt;cache-ref namespace=&quot;daoMapper.UserMapper&quot;/&gt;
</code></pre><p>由上面可知，mapper有两种配置方式，其中cache标签是声明此mapper使用二级缓存，具体参数如下：</p>
<ul>
<li>eviction：缓存刷新机制，默认可用的回收策略有四种，LRU（清理最近最少使用的缓存）、FIFO（先进先出）、SOFT（ 软引用:移除基于垃圾回收器状态和软引用规则的对象）和WEAK（更积极地移除基于垃圾收集器状态和弱引用规则的对象。）</li>
<li>flushInterval：刷新间隔，可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</li>
<li>size：引用数目，可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</li>
<li>readOnly：只读属性，可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</li>
</ul>
<p>　　一级缓存是在BaseExecutor中进行操作，那二级缓存想要在一级之前调用自然就要在上一级了，MyBatis采用的是装饰器模式，当cacheEnabled设置为true时，默认创建的Executor实例都会用cacheEnabled进行装饰，下面看下cacheEnabled的查询源码：</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
     throws SQLException {
   Cache cache = ms.getCache();
   if (cache != null) {
     //根据flushCache参数决定是否刷新缓存区
     flushCacheIfRequired(ms);
     if (ms.isUseCache() &amp;&amp; resultHandler == null) {
       //校验boundSql中的绑定参数列表是否包含输出参数，如果包含则抛出异常，Mybatis不支持存储过程结果缓存
       ensureNoOutParams(ms, parameterObject, boundSql);
       @SuppressWarnings(&quot;unchecked&quot;)
       //从缓存中获取MappedStatement对应的查询结果
       List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
       if (list == null) {
         //如果没有缓存实例，则调用delegate执行query，并将结果放入缓存区
         list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
         tcm.putObject(cache, key, list); // issue #578 and #116
       }
       return list;
     }
   }
   //如果MappedStatement配置不使用缓存则直接调用delegate进行查询
   return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
 }
</code></pre><p>这里的List<e> list = (List<e>) tcm.getObject(cache, key);是重点，画一下，考试要考，咳咳。<br>　　此处可以看出cache其实是从MappedStatement中取出的，正是因为MappedStatement在MyBatis初始化时就全部创建完毕，所以不会和SqlSession的生命周期挂钩。下面看下之后的方法：</e></e></p>
<pre><code>public Object getObject(Cache cache, CacheKey key) {
    return getTransactionalCache(cache).getObject(key);
  }
private TransactionalCache getTransactionalCache(Cache cache) {
    TransactionalCache txCache = transactionalCaches.get(cache);
    //如果此SqlSession的缓存集合中不包含cache，则创建cache的装饰类TransactionalCache并放入transactionalCaches中
    if (txCache == null) {
      txCache = new TransactionalCache(cache);
      transactionalCaches.put(cache, txCache);
    }
    return txCache;
  }
  public Object getObject(Object key) {
    // 此处实际调用的是默认实现PerpetualCache的getObject方法
    Object object = delegate.getObject(key);
    if (object == null) {
      //此处是将缓存缓存的key放入缓存队列中，并没有直接放入二级缓存，只有调用commit方法才会将队列中的key依次放入二级缓存
      entriesMissedInCache.add(key);
    }
    // issue #146
    if (clearOnCommit) {
      return null;
    } else {
      return object;
    }
  }
</code></pre><p>　　上面说了二级缓存是从MappedStatement取出的，那么现在就来找一下二级缓存是如何创建的，之前讲创建SqlSessionFactory的过程时有提到过解析xml配置文件的方法，既然二级缓存的开关是在mapper.xml文件中，那么创建二级缓存的入口自然要落在解析mapper的方法中，下面来看下源码：</p>
<pre><code>private void cacheElement(XNode context) throws Exception {
    if (context != null) {
      //自定义缓存类型
      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);
      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);
      //缓存过期类型装饰类
      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);
      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);
      //缓存刷新间隔
      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);
      //引用数量
      Integer size = context.getIntAttribute(&quot;size&quot;);
      //是否只读
      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);
      boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);
      //cache标签张配置的propertie属性
      Properties props = context.getChildrenAsProperties();
      //创建缓存对象
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
    }
  }
public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,
      Class&lt;? extends Cache&gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    //创建缓存对象
    Cache cache = new CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    //将缓存对象添加至caches
    configuration.addCache(cache);
    //此处留待之后创建MappedStatement使用
    currentCache = cache;
    return cache;
  }
public Cache build() {
    //设置默认实现类PerpetualCache和装饰类LruCache
    setDefaultImplementations();
    //创建PerpetualCache实例
    Cache cache = newBaseCacheInstance(implementation, id);
    //设置propertie属性
    setCacheProperties(cache);
    if (PerpetualCache.class.equals(cache.getClass())) {
      //装饰者
      for (Class&lt;? extends Cache&gt; decorator : decorators) {
        cache = newCacheDecoratorInstance(decorator, cache);
        setCacheProperties(cache);
      }
      //根据flushInterval，readOnly，blocking属性装饰缓存
      cache = setStandardDecorators(cache);
    } else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) {
      cache = new LoggingCache(cache);
    }
    return cache;
  }
</code></pre><p>　　如果不想使用MyBatis默认的二级缓存实现，也可以接入第三方缓存，如redis等，或者自定义cache的实现类。<br>　　二级缓存有很多优点，但是也存在很大的局限性，那就是二级缓存只适合单表，而且这个表的操作都在同一个mapper中定义，因为如果多个mapper都可以操作同一张表，那么缓存中的数据的准确性就无<br>法保证，多表查询的缓存也是同理。<br>　　如果实在是想用二级缓存处理多表的数据也不是没有办法，使用拦截器将涉及的所有mapper的缓存全部刷新就可以保证数据的准确性，不过编写这样一个插件还要保证插件的兼容性、可扩展性、稳定性都<br>达到上线的水准还不如在设计的时候就避免这种坑了。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：ParameterHandler]]></title>
      <url>/2017/06/15/mybatis-7/</url>
      <content type="html"><![CDATA[<p>　　之前在Statementhandler中有一个成员变量叫ParameterHandler，这个就是第二个苦力（负责绑定参数）了，MyBatis中ParameterHandler只有一个默认实现，下面看一下绑定参数方法的源码：<br><a id="more"></a></p>
<pre><code>public void setParameters(PreparedStatement ps) {
    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());
    //获取sql对象中的参数集合
    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
    if (parameterMappings != null) {
      for (int i = 0; i &lt; parameterMappings.size(); i++) {
        //获取参数对象
        ParameterMapping parameterMapping = parameterMappings.get(i);
        //存储过程的输出参数在之前的CallableStatementHandler中绑定，此处不在赘述
        if (parameterMapping.getMode() != ParameterMode.OUT) {
          Object value;
          String propertyName = parameterMapping.getProperty();
          //获取需绑定参数的值
          if (boundSql.hasAdditionalParameter(propertyName)) { 
            value = boundSql.getAdditionalParameter(propertyName);
          } else if (parameterObject == null) {
            value = null;
          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
            value = parameterObject;
          } else {
            MetaObject metaObject = configuration.newMetaObject(parameterObject);
            value = metaObject.getValue(propertyName);
          }
          //获取此参数对应的类型处理器
          TypeHandler typeHandler = parameterMapping.getTypeHandler();
          JdbcType jdbcType = parameterMapping.getJdbcType();
          //如果参数值和jdbc类型为null，则此参数使用配置中指定的null类型表示，默认为JdbcType.OTHER
          if (value == null &amp;&amp; jdbcType == null) {
            jdbcType = configuration.getJdbcTypeForNull();
          }
          try {
            //将参数绑定到PreparedStatement
            typeHandler.setParameter(ps, i + 1, value, jdbcType);
          } catch (TypeException e) {
            throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);
          } catch (SQLException e) {
            throw new TypeException(&quot;Could not set parameters for mapping: &quot; + parameterMapping + &quot;. Cause: &quot; + e, e);
          }
        }
      }
    }
  }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：ResultSetHandler]]></title>
      <url>/2017/06/15/mybatis-6/</url>
      <content type="html"><![CDATA[<p>　　现在要说第三个苦力ResultSetHandler（负责处理结果集映射）了，还记得在mapper配置中有一个标签叫resultMap，还有一个叫resultType，这两个标签就是这个时候用的了。ResultSetHandler接口只有一个默认的实现类，下面我们来看看关键的几个方法：<br><a id="more"></a></p>
<pre><code>/**
 * 依照配置的返回类型映射查询结果集
 */
 @Override
 public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

    //已处理结果行数
    int resultSetCount = 0;
    //ResultSetWrapper是ResultSet的包装类
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    //获取结果集
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    //判断是否有结果集，没有则抛出异常
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      //映射结果集
      handleResultSet(rsw, resultMap, multipleResults, null);
      //如果有多个结果集时，此处rsw不为null
      rsw = getNextResultSet(stmt);
      //清空缓存池
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResultSets();
    if (resultSets != null) {
      //当存在多个结果集时执行以下逻辑
      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          //获取嵌套结果集id
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          //从一级缓存中获取结果集
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          //绑定子结果集，此处的parentMapping为父级结果集
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        //获取下一个结果集
        rsw = getNextResultSet(stmt);
        //清空缓存池
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }

/**
 * 按照规则映射结果集数据
 */
private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
    try {
      //parentMapping不为空是指嵌套结果集，在mapper配置中的resultMap标签控制
      if (parentMapping != null) {
        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);
      } else {
        if (resultHandler == null) {//有多个结果集
          //创建一个默认的结果集对象
          DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);
          //将查询结果按照字段与bean属性对应关系进行绑定
          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
          //将结果集添加到multipleResults末尾
          multipleResults.add(defaultResultHandler.getResultList());
        } else {//简单结果集
          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);
        }
      }
    } finally {
      // issue #228 (close resultsets)
      closeResultSet(rsw.getResultSet());
    }
  }
/**
 * 映射数据
 */
public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
    if (resultMap.hasNestedResultMaps()) {
      ensureNoRowBounds();
      checkResultHandler();
      //嵌套的结果集
      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);
    } else {
      //普通的结果集
      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);
    }
  }
/**
 * 映射嵌套结果集
 */
private void handleRowValuesForNestedResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {
    //创建结果集上下文对象
    final DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;();
    //跳过rowBounds指定offset行偏移量
    skipRows(rsw.getResultSet(), rowBounds);
    //前一行数据
    Object rowValue = previousRowValue;
    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) {
      //鉴别器通过制定字段获取另一个结果的映射
      final ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);
      //获取结果集的唯一key
      final CacheKey rowKey = createRowKey(discriminatedResultMap, rsw, null);
      //从缓存中获取key对应的结果对象
      Object partialObject = nestedResultObjects.get(rowKey);
      //获取配置项resultOrdered，是否为嵌套结果集。
      if (mappedStatement.isResultOrdered()) {
        if (partialObject == null &amp;&amp; rowValue != null) {
          nestedResultObjects.clear();
          //存储结果对象
          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
        }
        //获取行值
        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);
      } else {
        rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, null, partialObject);
        if (partialObject == null) {
          storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
        }
      }
    }
    if (rowValue != null &amp;&amp; mappedStatement.isResultOrdered() &amp;&amp; shouldProcessMoreRows(resultContext, rowBounds)) {
      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
      previousRowValue = null;
    } else if (rowValue != null) {
      previousRowValue = rowValue;
    }
  }
/**
 * 简单结果集的绑定行数据方法
 */
private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)
      throws SQLException {
    DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;();
    //跳过rowBounds指定offset行偏移量
    skipRows(rsw.getResultSet(), rowBounds);
    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) {
      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);
      //获取一行数据
      Object rowValue = getRowValue(rsw, discriminatedResultMap);
      //存储数据对象
      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());
    }
  }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：StatementHandler]]></title>
      <url>/2017/06/15/mybatis-5/</url>
      <content type="html"><![CDATA[<p>上文说到Executor是Mybatis的执行者，Mybatis为了防止工作量太大而暴走就准备了几个苦力供他差遣。</p>
<ul>
<li>StatementHandler：负责生产statement实例以及监督statement执行sql操作。</li>
<li>ParameterHandler：负责绑定参数。</li>
<li>ResultSetHandler：负责处理结果集</li>
</ul>
<a id="more"></a>
<p>本次先说说StatementHandler这个苦力。下团是StatementHandler的家族体系：<br><img src="/images/mybatis_8.png" alt=""></p>
<p>　　可以看出StatementHandler和他的带头大哥一样是使用的模板模式，下面就先看下这个模板类BaseStatementHandler。</p>
<h2 id="BaseStatementHandler"><a href="#BaseStatementHandler" class="headerlink" title="BaseStatementHandler"></a>BaseStatementHandler</h2><p>　　BaseStatementHandler需要关注的方法只有一个，下面来看下源码：</p>
<pre><code>public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException {
    ErrorContext.instance().sql(boundSql.getSql());
    Statement statement = null;
    try {
      //实例化statement，由子类进行差异化实现
      statement = instantiateStatement(connection);
      //设置statement超时时间
      setStatementTimeout(statement, transactionTimeout);
      //设置每次返回的结果集大小，取决于xml中的fetchSize值
      setFetchSize(statement);
      return statement;
    } catch (SQLException e) {
      closeStatement(statement);
      throw e;
    } catch (Exception e) {
      closeStatement(statement);
      throw new ExecutorException(&quot;Error preparing statement.  Cause: &quot; + e, e);
    }
  }
</code></pre><h2 id="SimpleStatementHandler"><a href="#SimpleStatementHandler" class="headerlink" title="SimpleStatementHandler"></a>SimpleStatementHandler</h2><p>　　一看名字就知道了，这是执行简单sql小分队的苦力，正好用来举例，先来看看CRUD方法：</p>
<pre><code>public int update(Statement statement) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //获取参数对象
    Object parameterObject = boundSql.getParameterObject();
    //获取主键生产器
    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
    int rows;
    //根据KeyGenerator的具体类型决定是否返回修改数据的主键，具体逻辑放在KeyGenerator中讲解
    if (keyGenerator instanceof Jdbc3KeyGenerator) {
      statement.execute(sql, Statement.RETURN_GENERATED_KEYS);
      //获取修改行数
      rows = statement.getUpdateCount();
      //将返回的主键信息添加到parameterObject中
      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);
    } else if (keyGenerator instanceof SelectKeyGenerator) {
      statement.execute(sql);
      rows = statement.getUpdateCount();
      keyGenerator.processAfter(executor, mappedStatement, statement, parameterObject);
    } else {
      statement.execute(sql);
      rows = statement.getUpdateCount();
    }
    return rows;
  }
public void batch(Statement statement) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行批处理
    statement.addBatch(sql);
  }
public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行查询
    statement.execute(sql);
    //处理结果集
    return resultSetHandler.&lt;E&gt;handleResultSets(statement);
  }
public &lt;E&gt; Cursor&lt;E&gt; queryCursor(Statement statement) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行查询
    statement.execute(sql);
    //处理结果集
    return resultSetHandler.&lt;E&gt;handleCursorResultSets(statement);
  }
  protected Statement instantiateStatement(Connection connection) throws SQLException {
    if (mappedStatement.getResultSetType() != null) {
      //创建能返回指定类型的ResultSet的Statement实例
      return connection.createStatement(mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
    } else {
      //创建普通Statement实例
      return connection.createStatement();
    }
  }
</code></pre><p>simple不愧simple之名，除了update稍微复杂点都很简单，需要注意的是SimpleStatementHandler中的parameterize方法是没有实现的，即不支持绑定参数。</p>
<h2 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h2><p>　　这个是预编译小组的小伙伴，这个小伙伴和simple挺像，甚至update比simple还要简单，真不知道到底他俩谁才更像simple（笑），不过说归说这次的是有很大不同的，下面看下源码：</p>
<pre><code>protected Statement instantiateStatement(Connection connection) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {
      //获取xml配置的指定列名
      String[] keyColumnNames = mappedStatement.getKeyColumns();
      if (keyColumnNames == null) {
        //创建能返回自动生成键的PreparedStatement实例
        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
      } else {
        //创建能返回指定数组指定的自动生成键的PreparedStatement实例
        return connection.prepareStatement(sql, keyColumnNames);
      }
    } else if (mappedStatement.getResultSetType() != null) {
      //创建能返回指定类型的ResultSet的PreparedStatement实例
      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
    } else {
      //创建普通PreparedStatement实例
      return connection.prepareStatement(sql);
    }
  }
public int update(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    //执行sql
    ps.execute();
    //获取修改的行数
    int rows = ps.getUpdateCount();
    //获取参数对象
    Object parameterObject = boundSql.getParameterObject();
    //获取主键生成器
    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
    //将修改行的主键信息反写回parameterObject
    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);
    return rows;
  }
public void parameterize(Statement statement) throws SQLException {
    parameterHandler.setParameters((PreparedStatement) statement);
  }
</code></pre><h2 id="CallableStatementHandler"><a href="#CallableStatementHandler" class="headerlink" title="CallableStatementHandler"></a>CallableStatementHandler</h2><p>　　顾名思义这个就是处理存储过程的小伙伴了，他的修改. 查询方法与上面两位几乎相同就不在赘述了，下面看下不一样的地方：</p>
<pre><code>protected Statement instantiateStatement(Connection connection) throws SQLException {
    String sql = boundSql.getSql();
    if (mappedStatement.getResultSetType() != null) {
      //创建返回指定ResultSet类型的CallableStatement实例
      return connection.prepareCall(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
    } else {
      //创建CallableStatement实例
      return connection.prepareCall(sql);
    }
  }

public void parameterize(Statement statement) throws SQLException {
    //注册输出参数
    registerOutputParameters((CallableStatement) statement);
    //绑定参数
    parameterHandler.setParameters((CallableStatement) statement);
  }

  private void registerOutputParameters(CallableStatement cs) throws SQLException {
    //获取参数集合
    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
    for (int i = 0, n = parameterMappings.size(); i &lt; n; i++) {
      //获取参数对象
      ParameterMapping parameterMapping = parameterMappings.get(i);
      //参数类型为输出参数时才会进行绑定
      if (parameterMapping.getMode() == ParameterMode.OUT || parameterMapping.getMode() == ParameterMode.INOUT) {
        //如果参数没有指定jdbc类型则抛出异常
        if (null == parameterMapping.getJdbcType()) {
          throw new ExecutorException(&quot;The JDBC Type must be specified for output parameter.  Parameter: &quot; + parameterMapping.getProperty());
        } else {
          //将指定位置的参数注册为jdbc类型
          if (parameterMapping.getNumericScale() != null &amp;&amp; (parameterMapping.getJdbcType() == JdbcType.NUMERIC || parameterMapping.getJdbcType() == JdbcType.DECIMAL)) {
            cs.registerOutParameter(i + 1, parameterMapping.getJdbcType().TYPE_CODE, parameterMapping.getNumericScale());
          } else {
            if (parameterMapping.getJdbcTypeName() == null) {
              cs.registerOutParameter(i + 1, parameterMapping.getJdbcType().TYPE_CODE);
            } else {
              cs.registerOutParameter(i + 1, parameterMapping.getJdbcType().TYPE_CODE, parameterMapping.getJdbcTypeName());
            }
          }
        }
      }
    }
  }
</code></pre><h2 id="RoutingStatementHandler"><a href="#RoutingStatementHandler" class="headerlink" title="RoutingStatementHandler"></a>RoutingStatementHandler</h2><p>　　MyBatis中默认实现的StatementHandler就是RoutingStatementHandler，RoutingStatementHandler并没有实现具体的业务逻辑，而是作为一个选择器的角色存在，通过配置中的设置决定实例化哪种子类</p>
<pre><code>public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
   switch (ms.getStatementType()) {
     case STATEMENT:
       delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
       break;
     case PREPARED:
       delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
       break;
     case CALLABLE:
       delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
       break;
     default:
       throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());
   }
 }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：Executor]]></title>
      <url>/2017/06/15/mybatis-4/</url>
      <content type="html"><![CDATA[<p>　　前面提到了SqlSession很懒，操作都下放给了Executor这个执行者，Executor是MyBatis的执行器接口，子类如下图：<br><img src="/images/mybatis_7.png" alt=""><br><a id="more"></a></p>
<h2 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h2><p>　　BaseExecutor实现了Executor接口的所有方法，采用了模板模式，为下面几个子类提供公共实现。首先看下update方法的源码：</p>
<pre><code>public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());
    //如果已经关闭则抛出异常
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //执行更新操作会清空一级缓存
    clearLocalCache();
    //由子类做差异化实现
    return doUpdate(ms, parameter);
  }
</code></pre><p>由上可见，update的模板方法比较简单，只是清空了以及缓存，外加关闭异常，具体的操作由子类的doUpdate实现决定。下面看下query方法的源码：</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  //获取sql对象
  BoundSql boundSql = ms.getBoundSql(parameter);
  //获取缓存key
   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
   return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
}
</code></pre><p>此处首先获取MyBatis的sql对象BoundSql和缓存key，然后调用下面方法：</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    //如果已经关闭则抛出异常
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //当查询堆栈为0且flushCacheRequired配置为true则刷新一级缓存区
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
      queryStack++;
      //根据参数中的resultHandler来判断是否从一级缓存中获取结果集，selectList方法传入的resultHandler默认为null
      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
      if (list != null) {//缓存中存在结果集时
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        //从数据库获取数据
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    //当查询堆栈为0时加载延迟加载列表中的所有元素
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      //清空延迟加载列表
      deferredLoads.clear();
      //如果设置的本地缓存等级为statement，则清空一级缓存
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache();
      }
    }
    return list;
  }
private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&lt;E&gt; list;
    //执行查询前用占位符在一级缓存中占位
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //具体查询方法，由子类进行差异化实现
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //将结果集放入一级缓存中
    localCache.putObject(key, list);
    //如果statement的类型为CALLABLE，在localOutputParameterCache中放入参数
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
</code></pre><p>由上述方法可见，query的具体实现方法是doQuery，也是由子类进行差异化实现。</p>
<pre><code>public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException {
    //获取sql对象
    BoundSql boundSql = ms.getBoundSql(parameter);
    return doQueryCursor(ms, parameter, rowBounds, boundSql);
  }
</code></pre><p>cursor是3.4版本新增的特性，用于以游标的方式返回结果，主要用于数据量很大的业务场景，会分批次读取数据，降低每次对数据库的占用时间。</p>
<h2 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h2><p>　　简单sql执行器，不支持添加参数。这里用doQuery方法进行示例：</p>
<pre><code>  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      //获取配置上下文
      Configuration configuration = ms.getConfiguration();
      //创建StatementHandler实例
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //创建statement实例，具体生成过程会放在StatementHandler模块讲解
      stmt = prepareStatement(handler, ms.getStatementLog());
      //具体执行操作
      return handler.&lt;E&gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    //获取数据库连接
    Connection connection = getConnection(statementLog);
    //创建statement实例
    stmt = handler.prepare(connection, transaction.getTimeout());
    //为statement实例绑定参数，（simple类型无方法体）
    handler.parameterize(stmt);
    return stmt;
  }
</code></pre><h2 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a>ReuseExecutor</h2><p>　　可重复使用执行器，内部维护了一个Map<string, statement="">缓存池，在一个session生命周期内相同的statement只会实例化一次。与simple的主要差异在于下面两个方法</string,></p>
<pre><code>public List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException {
    //遍历statement缓存池，依次关闭
    for (Statement stmt : statementMap.values()) {
      closeStatement(stmt);
    }
    //清空缓存池
    statementMap.clear();
    return Collections.emptyList();
  }
 private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    //获取sql对象
    BoundSql boundSql = handler.getBoundSql();
    String sql = boundSql.getSql();
    //判断缓存池中是否有此sql的statement实例
    if (hasStatementFor(sql)) {
      //获取缓存池中的statement实例
      stmt = getStatement(sql);
      //设置事务过期时间
      applyTransactionTimeout(stmt);
    } else {
      //缓存池中没有此sql的statement实例时，通过StatementHandler创建新实例
      Connection connection = getConnection(statementLog);
      stmt = handler.prepare(connection, transaction.getTimeout());
      //将statement实例放入缓存池
      putStatement(sql, stmt);
    }
    //为statement绑定参数
    handler.parameterize(stmt);
    return stmt;
  }
</code></pre><h2 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a>BatchExecutor</h2><p>批处理执行器，BatchExecutor内维护了四个变量，分别是</p>
<ul>
<li>statementList：statement执行队列</li>
<li>batchResultList：结果集队列</li>
<li>currentSql：上次执行sql</li>
<li>currentStatement：上次执行MappedStatement</li>
</ul>
<p>批处理的doQuery方法与simple的差别只在于会清空上述四个变量的值，批处理特性主要体现在doUpdate和doFlushStatements这两个方法中：</p>
<pre><code>public int doUpdate(MappedStatement ms, Object parameterObject) throws SQLException {
    //获取配置上下文
    final Configuration configuration = ms.getConfiguration();
    //创建StatementHandler实例
    final StatementHandler handler = configuration.newStatementHandler(this, ms, parameterObject, RowBounds.DEFAULT, null, null);
    //从MappedStatement中获取sql对象
    final BoundSql boundSql = handler.getBoundSql();
    final String sql = boundSql.getSql();
    final Statement stmt;
    //判断本次执行sql是否与上次执行sql相同
    if (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) {
      int last = statementList.size() - 1;
      //获取上次使用的Statement实例
      stmt = statementList.get(last);
      //刷新事务过期时间
      applyTransactionTimeout(stmt);
      //为Statement绑定新参数
      handler.parameterize(stmt);
      //将参数对象添加至BatchResult对象中（BatchResult中维护了一个参数List）
      BatchResult batchResult = batchResultList.get(last);
      batchResult.addParameterObject(parameterObject);
    } else {
      //获取新的数据库连接实例
      Connection connection = getConnection(ms.getStatementLog());
      //创建Statement实例
      stmt = handler.prepare(connection, transaction.getTimeout());
      //为Statement绑定参数
      handler.parameterize(stmt); 
      //刷新上次执行sql以及Statement，为下次判断做准备
      currentSql = sql;
      currentStatement = ms;
      statementList.add(stmt);
      //在结果集队列中添加BatchResult对象实例
      batchResultList.add(new BatchResult(ms, sql, parameterObject));
    }
    handler.batch(stmt);
    //批处理执行器的更新操作不会返回修改行数，而是返回一个固定的数字，此处需要注意！
    return BATCH_UPDATE_RETURN_VALUE;
  }
public List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException {
    try {
      List&lt;BatchResult&gt; results = new ArrayList&lt;BatchResult&gt;();
      //如果rollback则返回空集
      if (isRollback) {
        return Collections.emptyList();
      }
      for (int i = 0, n = statementList.size(); i &lt; n; i++) {
        //从statement队列中获取statement实例
        Statement stmt = statementList.get(i);
        //设置事务超时时间
        applyTransactionTimeout(stmt);
        //从结果集队列中获取BatchResult实例，结果集队列与上面statement队列是一一对应关系
        BatchResult batchResult = batchResultList.get(i);
        try {
          //设置本次操作修改的行数（int数组形式）,需要注意的是多次执行相同的修改sql时，结果信息会保存在同一个BatchResult实例中
          batchResult.setUpdateCounts(stmt.executeBatch());
          MappedStatement ms = batchResult.getMappedStatement();
          List&lt;Object&gt; parameterObjects = batchResult.getParameterObjects();
          KeyGenerator keyGenerator = ms.getKeyGenerator();
          //此处是回写字段逻辑，如果在xml中配置了需要回写的字段，则会调用KeyGenerator进行回写，具体逻辑在KeyGenerator讲解
          if (Jdbc3KeyGenerator.class.equals(keyGenerator.getClass())) {
            Jdbc3KeyGenerator jdbc3KeyGenerator = (Jdbc3KeyGenerator) keyGenerator;
            jdbc3KeyGenerator.processBatch(ms, stmt, parameterObjects);
          } else if (!NoKeyGenerator.class.equals(keyGenerator.getClass())) { 
            for (Object parameter : parameterObjects) {
              keyGenerator.processAfter(this, ms, stmt, parameter);
            }
          }
        } catch (BatchUpdateException e) {
          StringBuilder message = new StringBuilder();
          message.append(batchResult.getMappedStatement().getId())
              .append(&quot; (batch index #&quot;)
              .append(i + 1)
              .append(&quot;)&quot;)
              .append(&quot; failed.&quot;);
          if (i &gt; 0) {
            message.append(&quot; &quot;)
                .append(i)
                .append(&quot; prior sub executor(s) completed successfully, but will be rolled back.&quot;);
          }
          throw new BatchExecutorException(message.toString(), e, results, batchResult);
        }
        results.add(batchResult);
      }
      return results;
    } finally {
      //清空批处理队列
      for (Statement stmt : statementList) {
        closeStatement(stmt);
      }
      currentSql = null;
      statementList.clear();
      batchResultList.clear();
    }
  }
</code></pre><h2 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h2><p>　　缓存执行器，顾名思义这种执行器内部必定维护了一个缓存区，也主要针对于查询语句，具体代码如下：</p>
<pre><code>//实际的操作执行器
private Executor delegate;
//缓存容器，缓存实体TransactionalCache实现了Cache接口
private TransactionalCacheManager tcm = new TransactionalCacheManager();
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    Cache cache = ms.getCache();
    if (cache != null) {
      //根据flushCache参数决定是否刷新缓存区
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;&amp; resultHandler == null) {
        //如果执行存储过程，校验boundSql中的绑定参数列表是否包含输出参数，如果包含则抛出异常
        ensureNoOutParams(ms, parameterObject, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        //从缓存中获取MappedStatement对应的查询结果
        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
        if (list == null) {
          //如果没有缓存实例，则调用delegate执行query，并将结果放入缓存区
          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    //如果MappedStatement配置不使用缓存则直接调用delegate进行查询
    return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：SqlSession]]></title>
      <url>/2017/06/15/mybatis-3/</url>
      <content type="html"><![CDATA[<p>　　顾名思义SqlSession指的就是数据库会话，之前说过SqlSessionFactory如何生成SqlSession实例，本次不在赘述。</p>
<p>　　session中包含了两种执行sql的形式，一种是传统的CRUD，另一种是mapper形式。官方文档推荐使用mapper形式，理由是代码更优雅（笑）。其实主要是mapper形式更加简易，而且通过接口+xml的开发模式代码耦合性很低，更符合开闭原则，而且逻辑看起来更加清晰，配合MyBatis的异常系统定位异常位置简单粗暴（笑哭）。先看下传统的调用方式，下面是outline图：<br><img src="/images/mybatis_6.png" alt=""><br><a id="more"></a><br>　　这么多方法自然不能一一说明，此处仅取selectList方法进行示例说明：</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
   try {
     //在configuration中维护了一个Map&lt;String, MappedStatement&gt;集合，在初始化的时候会读取所有sql配置文件中的信息，
     //每个sql会生成一个对应的上下文MappedStatement，缓存在这个集合中。
     MappedStatement ms = configuration.getMappedStatement(statement);
     //具体操作下放至Executor执行
     return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
   } catch (Exception e) {
     throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
   } finally {
     ErrorContext.instance().reset();
   }
 }
</code></pre><p>　　源码里写的很简练，第一步获取初始化时创建的sql的对应上下文对象，第二部将具体操作下放到Executor中执行。这里就体现出来SqlSession和Executor的职务差别，SqlSession只负责构造一个sql操作的执行环境，Executor只负责对数据库操作，分工明确。</p>
<p>下面看一下mapper形式是如何执行sql操作的：</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
   return configuration.&lt;T&gt;getMapper(type, this);
 }
</code></pre><p>很简单，直接甩锅给configuration（笑），而configuration里又有一个MapperRegistry对象，这个对象可是很关键，MapperRegistry在初始化时会缓存所有mapper接口的反射工厂实例，下面看两个关键的方法：</p>
<pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
    //mapper类限定只能是接口
    if (type.isInterface()) {
      //初始化上下文时会注册所有已检索的mapper接口，所以通常不会出现这个异常，除非配置有问题
      if (hasMapper(type)) {
        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);
      }
      //用于finally中校验已注册的mapper对象是否是完整对象，如果对象信息不完整则从缓存中删除
      boolean loadCompleted = false;
      try {
        //knownMappers是一个Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;集合，
        //此处实例化一个mapper接口对应的MapperProxyFactory放入集合中，供之后实例化时调用。
        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        //此处会生成对应的MappedStatement，并且放入Configuration的缓存集合mappedStatements中
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    //首先获取mapper代理工厂实例
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      //通过工厂实例创建mapper的代理实例
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
  }
</code></pre><p>此处可以看到有一个关键的类MapperProxyFactory，顾名思义这是个mapper代理工厂类，而实际的代理类是MapperProxy，下面看一下MapperProxy的invoke方法：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   try {
     //如果代理的是object类，则直接调用被代理方法
     if (Object.class.equals(method.getDeclaringClass())) {
       return method.invoke(this, args);
     } else if (isDefaultMethod(method)) {
       //如果代理执行的方法是接口的默认实现方法（jdk1.8中加入），则创建一个接口实例，执行此方法
       return invokeDefaultMethod(proxy, method, args);
     }
   } catch (Throwable t) {
     throw ExceptionUtil.unwrapThrowable(t);
   }
   //如果执行的方法是属于已注册mapper接口的抽象方法，则执行下面方法。先在methodCache缓存中获取MapperRegistry注册mapper接口时生成
   //在MapperRegistry注册mapper接口时会创建一个接口方法实例缓存池methodCache，每次执行接口代理方法时会查询缓存池中是否包含此方法的实例，
   //如果不存在，则创建对应方法实例放入缓存，并执行代理方法。
   final MapperMethod mapperMethod = cachedMapperMethod(method);
   return mapperMethod.execute(sqlSession, args);
 }
</code></pre><p>这个MapperMethod是MyBatis中的sql操作方法类，暴露给外部调用的也只有execute(SqlSession sqlSession, Object[] args)方法而已，下面看下这个方法的代码：</p>
<pre><code>public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    //根据sql类型判断执行的方法
    switch (command.getType()) {
      case INSERT: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      case UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        break;
      }
      case DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        break;
      }
      case SELECT:
        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } else if (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } else if (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } else {
          Object param = method.convertArgsToSqlCommandParam(args);
          result = sqlSession.selectOne(command.getName(), param);
        }
        break;
      case FLUSH:
        result = sqlSession.flushStatements();
        break;
      default:
        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
      throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() 
          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    return result;
  }
</code></pre><p>由上可见，其实mapper形式写法最终还是调用SqlSession中的一系列方法，这么看来MyBatis官方文档中说的使用mapper看起来更优雅还真是实至名归（笑）</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：SqlSessionFactory]]></title>
      <url>/2017/06/15/mybatis-2/</url>
      <content type="html"><![CDATA[<p>　　使用MyBatis框架时，首先要使用SqlSessionFactoryBuilder.build方法来实例化一个SqlSessionFactory，SqlSessionFactory相当于一个数据库连接工厂。<br>SqlSessionFactory接口定义了生成SqlSession实例的几种两种方式，MyBatis中有两个默认实现DefaultSqlSessionFactory和SqlSessionManager。SqlSessionManager貌似已经废弃，此处不再写。<br><a id="more"></a><br>　　DefaultSqlSessionFactory内部维护了一个Configuration实例，Configuration中的配置属性是生成SqlSession实例的关键。下面是DefaultSqlSessionFactory的OutLine图：<br><img src="/images/mybatis_5.png" alt=""></p>
<p>看似很多种重载方法，但是实际执行的只有两个</p>
<ul>
<li>openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit)</li>
<li>openSessionFromConnection(ExecutorType execType, Connection connection)</li>
</ul>
<p>　　这两个方法的区别就在于是从Configuration中获取事务管理器工厂创建事务管理器，还是从Connection中获取事务管理器。下面取第一个方法做示例：</p>
<pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;
  try {
    //获取数据源对象
    final Environment environment = configuration.getEnvironment();
    //获取事务工厂，如果数据源不存在或者数据源中没有实例化事务工厂，则创建ManagedTransactionFactory实例作为事务工厂使用
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    //实例化事务控制器
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    //实例化Executor执行器
    final Executor executor = configuration.newExecutor(tx, execType);
    //实例化SqlSession
    return new DefaultSqlSession(configuration, executor, autoCommit);
  } catch (Exception e) {
    closeTransaction(tx); // may have fetched a connection so lets call close()
    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}　
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：SqlSessionFactoryBuilder]]></title>
      <url>/2017/06/15/mybatis-1/</url>
      <content type="html"><![CDATA[<p>　　SqlSessionFactoryBuilder是MyBatis的执行入口，使用MyBatis首先要构建一个SqlSessionFactory容器，SqlSessionFactoryBuilder就是构建SqlSessionFactory的创建者。<br>　　以下是SqlSessionFactoryBuilder的OutLine：<br><img src="/images/mybatis_4.png" alt=""><br><a id="more"></a><br>实际执行的build只有三个:</p>
<ul>
<li>build(InputStream inputStream, String environment, Properties properties)</li>
<li>build(Reader reader, String environment, Properties properties)</li>
<li>build(Configuration config)</li>
</ul>
<p>　　前两种的区别只有使用字符流还是字节流，本质上都是通过读取MyBatis的配置文件来进行初始化工作。其中environment可以指定使用的数据源，需要使用多个库的时候会用到这个参数，需要注意的是每个SqlSessionFactory只能对应一个数据源。properties参数可以定义额外的配置参数，与properties文件中配置的功能相同。而第三种是以编程的方式对MyBatis容器进行初始化。（注：前两种最后还是会调用第三种方法）</p>
<p>下面取第一个build的源码进行示例：</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}
</code></pre><p>由上面代码一看可知，初始化配置的关键在于XMLConfigBuilder这个解析类的parse()，parse()方法对MyBatis的一系列标签进行归类注册，创建容器实例，具体代码如下：</p>
<pre><code>private void parseConfiguration(XNode root) {
    try {
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre><p>　　值得注意的是properties和environments，这两个在XMLConfigBuilder的构造方法中是可以当做参数传入的，其中properties会在初始化properties标签时将参数中的properties添加到对应集合中，而environments如果不为空，则会使用id为environments对应值的数据源，否则会使用默认的数据源。其余每个方法对应的都是MyBatis配置文件中的一种标签，具体内容可以在MyBatis的官方文档查询，此处不再赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis架构设计总结]]></title>
      <url>/2017/06/14/mybatis/</url>
      <content type="html"><![CDATA[<h2 id="MyBatis的架构"><a href="#MyBatis的架构" class="headerlink" title="MyBatis的架构"></a>MyBatis的架构</h2><p><img src="/images/mybatis_1.png" alt=""></p>
<a id="more"></a>
<h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><p>接口层提供了与数据库交互的入口，MyBatis支持两种方式的接口调用</p>
<ul>
<li>传统API方式</li>
<li>mapper接口方式</li>
</ul>
<h4 id="传统API"><a href="#传统API" class="headerlink" title="传统API"></a>传统API</h4><p><img src="/images/mybatis_2.png" alt=""><br>　　例：int i = session.selectOne(“daoMapper.UserMapper.selectIDByUser”, u);<br>　　传统API的方式虽然很简洁，但是并不方便，不仅要根据sql类型手动选择调用的方法，而且StatementID使用字符串形式的拼写也加大了人为错误的因素，并不符合框架避免人为错误的这一个特点。</p>
<h3 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h3><p>　　MyBatis支持两种Mapper接口的实现形式一种是java注解，一种是xml配置。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><pre><code>@Select(&quot;select id from users where phoneNO = #{phoneNO}&quot;)
public int selectID(String phoneNO);
</code></pre><p>注解形式开发比较简单，但是不适合比较复杂的sql。</p>
<h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><pre><code>mapper.java:
public User selectUser(Integer id);

mapper.xml:
&lt;select id=&quot;selectUser&quot; resultType=&quot;dao.User&quot; &gt;
  select * from policy where id=#{id}
 &lt;/select&gt;
</code></pre><p>　　xml配置自由度更大，而且支持动态拼接sql，可以根据传入参数. 条件等决定最终生成的sql对象。<br>　　Mapper接口的调用入口是Configuration.getMapper，MyBatis在初始化运行环境上下文（Configuration）时会读取配置的mapper文件，为mapper中配置的xml文件生成对应的statement，在调用mapper中的方法时，MyBatis会根据方法名和mapper名确定一个唯一的StatementID，值得注意的是mapper形式其实也是调用传统API进行操作的。</p>
<h2 id="2-数据处理层"><a href="#2-数据处理层" class="headerlink" title="2.数据处理层"></a>2.数据处理层</h2><p>数据处理层可以说是MyBatis的核心精华所在，主要包括以下三个功能：</p>
<ul>
<li>处理参数生成动态SQL</li>
<li>数据库操作</li>
<li>处理结果集</li>
</ul>
<h4 id="处理参数生成动态SQL"><a href="#处理参数生成动态SQL" class="headerlink" title="处理参数生成动态SQL"></a>处理参数生成动态SQL</h4><p>　　动态生成SQL是一个很优雅的设计，MyBatis通过请求传入的参数对象和Ognl表达式来动态生成需要执行的sql语句，这使得设计sql的时候有很强的灵活性和扩展性。处理参数这部分主要分为两步，首先是查询的时候通过preparedStatement将参数对象与jdbc类型进行映射，其次是查询出结果集时，通过resultSet将查询结果与java类型进行映射。</p>
<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>　　MyBatis底层与数据库的交互依然是使用的JDBC实现，主要通过Executor这个执行者协调各个模块完成请求操作。</p>
<h4 id="处理结果集"><a href="#处理结果集" class="headerlink" title="处理结果集"></a>处理结果集</h4><p>　　MyBatis会将数据库返回的结果映射为List<e>的形式，这里要提到ResultMap，这个标签的功能很强大，可以完成多层多类型嵌套，支持多对一或一对多的数据形式。下面是一个例子：</e></p>
<pre><code>&lt;resultMap type=&quot;com.ymt.config.protectplan.domain.dto.ProtectplanDto&quot; id=&quot;protectplanDetail&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;protectPlanID&quot;/&gt;
    &lt;result property=&quot;protectPlanName&quot; column=&quot;protectPlanName&quot;/&gt;
    &lt;result property=&quot;protectPlanDesc&quot; column=&quot;protectPlanDesc&quot;/&gt;
    &lt;result property=&quot;protectplanStatus&quot; column=&quot;protectplanStatus&quot;/&gt;
    &lt;result property=&quot;createTime&quot; column=&quot;protectPlanCreateTime&quot;/&gt;
    &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanLastUpdate&quot;/&gt;
    &lt;collection property=&quot;detailList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;protectPlanContentID&quot;/&gt;
        &lt;result property=&quot;protectPlanContName&quot; column=&quot;protectPlanContName&quot;/&gt;
        &lt;result property=&quot;protectPlanID&quot; column=&quot;protectPlanID&quot;/&gt;
        &lt;result property=&quot;protectPlanContentType&quot; column=&quot;protectPlanContentType&quot;/&gt;
        &lt;result property=&quot;priority&quot; column=&quot;priority&quot;/&gt;
        &lt;result property=&quot;createTime&quot; column=&quot;protectPlanContentCreateTime&quot;/&gt;
        &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanContentLastUpdate&quot;/&gt;
        &lt;collection property=&quot;insuranceList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
            &lt;id property=&quot;kindID&quot; column=&quot;kindID&quot;/&gt;
            &lt;result property=&quot;hasFree&quot; column=&quot;hasFree&quot;/&gt;
            &lt;result property=&quot;isFree&quot; column=&quot;isFree&quot;/&gt;
            &lt;result property=&quot;mainFlag&quot; column=&quot;mainFlag&quot;/&gt;
            &lt;result property=&quot;amount&quot; column=&quot;detailAmount&quot;/&gt;
            &lt;collection property=&quot;amountList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
                &lt;id  column=&quot;customID&quot;/&gt;
                &lt;result property=&quot;amount&quot; column=&quot;amount&quot;/&gt;
                &lt;result property=&quot;amountShow&quot; column=&quot;amountShow&quot;/&gt;
                &lt;result property=&quot;isDefault&quot; column=&quot;isDefault&quot;/&gt;
            &lt;/collection&gt;
        &lt;/collection&gt;    
    &lt;/collection&gt;
&lt;/resultMap&gt;        
</code></pre><h3 id="支撑服务层"><a href="#支撑服务层" class="headerlink" title="支撑服务层"></a>支撑服务层</h3><p>　　支撑服务层主要为数据处理层提供额外功能。</p>
<h4 id="元对象模块"><a href="#元对象模块" class="headerlink" title="元对象模块"></a>元对象模块</h4><p>　　元对象是MyBatis的一个独立的模块，提供了一种简洁而优雅的访问对象的方式，使得开发时只需要专注于具体的业务，而不需要关注反射细节，并且无需手动处理各种反射异常。其具体实现是依赖与java的反射机制，所以嘛性能是有点损耗的，不过比起方便程度来说也是可以接受的。（不依赖其他模块，可以单独提出使用）</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>　　在越来越高的并发量的冲击下，不论是服务器还是数据库的压力都越来越大，缓存机制就是缓解数据库这方面的访问压力的。MyBatis设置了两个缓存层级，一级缓存存在于一次SqlSession会话内，一次会话可以不必重复查询相同的数据，二级缓存可以跨SqlSession存在，但是有很大风险。总之，使用MyBatis的缓存要谨慎，不然反而会影响程序的时效性。</p>
<h4 id="拦截器机制"><a href="#拦截器机制" class="headerlink" title="拦截器机制"></a>拦截器机制</h4><p>　　拦截器是MyBatis提供的一种可以改变自身运行机制的方式，拦截器仅支持拦截Executor. StatementHandler. ResultSetHandler. ParameterHandler。可以对MyBatis做一些定制化的修改，比如常用的分页，分库分表，读写分离，分类缓存等。</p>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>　　事务管理是ORM框架的一个必不可少的部分。</p>
<h4 id="连接池机制"><a href="#连接池机制" class="headerlink" title="连接池机制"></a>连接池机制</h4><p>　　创建数据库连接占据了一次会话的大部分时间，所以在访问量大的系统中，连接池就至关重要，连接池维护了所有数据库会话，节省了每次创建连接的性能开销。</p>
<h4 id="Sql的配置方式"><a href="#Sql的配置方式" class="headerlink" title="Sql的配置方式"></a>Sql的配置方式</h4><p>　　MyBatis的传统配置方式是基于xml配置，但是面向接口编程之风越来越盛，而且xml配置也很繁琐，并不适合简单sql，所以就诞生了一种符合面向接口编程思想的方式，而接口调用就引申出了注解这个大杀器，从此以后就可以使用mapper接口+注解的方式来配置sql，但是需要注意的是MyBatis对注解的支持还很简单，很多复杂的功能还是要用xml配置的。</p>
<h2 id="MyBatis的主要模块"><a href="#MyBatis的主要模块" class="headerlink" title="MyBatis的主要模块"></a>MyBatis的主要模块</h2><ul>
<li>SqlSession：数据库会话模块，MyBatis的顶层API，程序的调用入口。</li>
<li>Configuration：运行环境上下文，维护了MyBatis的所有配置信息，以及各种缓存区。</li>
<li>Executor：MyBatis的执行器，负责调度数据库操作的整个流程，完成各种缓存相关操作。</li>
<li>StatementHandler：封装了JDBC的Statement操作，包括设置参数，转换结果为List等。</li>
<li>ResultSetHandler：负责将结果集与java类型进行映射，转换为指定的类型。</li>
<li>ParameterHandler：负责处理参数对象，将参数与jdbc类型进行映射。</li>
<li>TypeHandle：类型处理器，主要负责jdbc与java的类型转换。</li>
<li>MapperStatement：维护了CRUD节点的信息。</li>
<li>SQLSource：根据传递的参数对象动态生成sql语句，并封装为BoundSql对象。</li>
<li>BoundSql：封装了sql相关的参数信息。</li>
<li>Plugin：拦截器组件，可以在一定程度上定制MyBatis的执行流程。</li>
<li>MetaObject：元对象模块，简洁而优雅的反射工具。</li>
</ul>
<p>(MyBatis只有这几个模块吗？当然不是，那为什么只写这几个是重点呢？这个嘛，当然是我只看了这几个模块的源码了=。=)<br><img src="/images/mybatis_3.png" alt=""></p>
<h2 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h2><p>此处由MyBatis的查询操作举例</p>
<h3 id="开启SqlSession"><a href="#开启SqlSession" class="headerlink" title="开启SqlSession"></a>开启SqlSession</h3><pre><code>InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,&quot;development1&quot;);
SqlSession session = sqlSessionFactory.openSession();
MyBatis的数据库会话封装在SqlSession中，SqlSession作为顶层API，肩负着增删改查的调度任务。
</code></pre><h3 id="SqlSession的查询"><a href="#SqlSession的查询" class="headerlink" title="SqlSession的查询"></a>SqlSession的查询</h3><pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //在configuration中维护了一个Map&lt;String, MappedStatement&gt;集合，在初始化的时候会读取所有sql配置文件中的信息，
      //每个sql会生成一个对应的上下文MappedStatement，缓存在这个集合中。
      MappedStatement ms = configuration.getMappedStatement(statement);
      //具体操作下放至Executor执行
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
</code></pre><p>　　在MyBatis初始化时，会根据加载的配置文件创建Configuration实例，mapper配置文件中的sql会生成对应的MappedStatement实例，Configuration维护了一个Map集合来缓存MappedStatement实例，key为nameSpace.functionName。<br>　　SqlSession会根据传入的statementID（即上面的key）获取配置缓存区中的MappedStatement实例，然后将操作参数交给Executor执行具体任务。</p>
<h3 id="Executor执行器"><a href="#Executor执行器" class="headerlink" title="Executor执行器"></a>Executor执行器</h3><h4 id="BaseExecutor"><a href="#BaseExecutor" class="headerlink" title="BaseExecutor"></a>BaseExecutor</h4><pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    //创建BoundSql实例
    BoundSql boundSql = ms.getBoundSql(parameter);
    //获取缓存key
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    //如果已经关闭则抛出异常
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //当查询堆栈为0且flushCacheRequired配置为true则刷新一级缓存区
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
      queryStack++;
      //根据参数中的resultHandler来判断是否从一级缓存中获取结果集，selectList方法传入的resultHandler默认为null
      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
      if (list != null) {//缓存中存在结果集时
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        //从数据库获取数据
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    //当查询堆栈为0时加载延迟加载列表中的所有元素
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      //清空延迟加载列表
      deferredLoads.clear();
      //如果设置的本地缓存等级为statement，则清空一级缓存
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache();
      }
    }
    return list;
  }
private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&lt;E&gt; list;
    //执行查询前用占位符在一级缓存中占位
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //具体查询方法，由子类进行差异化实现
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //将结果集放入一级缓存中
    localCache.putObject(key, list);
    //如果statement的类型为CALLABLE，在localOutputParameterCache中放入参数
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
</code></pre><p>BaseExecutor作为模板类，主要任务就是创建BoundSql实例. 处理一级缓存的内容，以及决定是否需要重新查询数据库取值，具体的数据库操作doQuery由子类进行差异化实现。</p>
<h4 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h4><pre><code>public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      //获取配置上下文
      Configuration configuration = ms.getConfiguration();
      //创建StatementHandler实例
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //创建statement实例，具体生成过程会放在StatementHandler模块讲解
      stmt = prepareStatement(handler, ms.getStatementLog());
      //具体执行操作
      return handler.&lt;E&gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
</code></pre><p>　　这里可以看出Executor的主要任务就是通过StatementHandler创建Statement实例，此时会将参数绑定到statement的指定位置，然后将任务下方到StatementHandler中，StatementHandler与JDBC进行交互。</p>
<h3 id="SimpleStatementHandler"><a href="#SimpleStatementHandler" class="headerlink" title="SimpleStatementHandler"></a>SimpleStatementHandler</h3><pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行查询
    statement.execute(sql);
    //处理结果集
    return resultSetHandler.&lt;E&gt;handleResultSets(statement);
  }
</code></pre><p>　　SimpleStatementHandler执行了sql语句，并将结果交给ResultSetHandler处理。</p>
<h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><pre><code>public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

    //已处理结果行数
    int resultSetCount = 0;
    //ResultSetWrapper是ResultSet的包装类
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    //获取结果集
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    //判断是否有结果集，没有则抛出异常
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      //映射结果集
      handleResultSet(rsw, resultMap, multipleResults, null);
      //如果有多个结果集时，此处rsw不为null
      rsw = getNextResultSet(stmt);
      //清空缓存池
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResultSets();
    if (resultSets != null) {
      //当存在多个结果集时执行以下逻辑
      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          //获取嵌套结果集id
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          //从一级缓存中获取结果集
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          //绑定子结果集，此处的parentMapping为父级结果集
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        //获取下一个结果集
        rsw = getNextResultSet(stmt);
        //清空缓存池
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
</code></pre><p>　　ResultSetHandler会将查询结果转换为List<e>的形式，如果调用的是selectOne方法，则会取List中的第一条数据返回，如果List为空会抛出异常。</e></p>
<p>上述只是简单描述了MyBatis的查询流程，其实具体细节有很多，无法一一列举，详细内容之后会单独在各个模块的源码讲解中详述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

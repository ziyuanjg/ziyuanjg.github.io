<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[mybatis_13]]></title>
      <url>/2017/06/15/mybatis-13/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_12]]></title>
      <url>/2017/06/15/mybatis-12/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_11]]></title>
      <url>/2017/06/15/mybatis-11/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_10]]></title>
      <url>/2017/06/15/mybatis-10/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_9]]></title>
      <url>/2017/06/15/mybatis-9/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_8]]></title>
      <url>/2017/06/15/mybatis-8/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_7]]></title>
      <url>/2017/06/15/mybatis-7/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_6]]></title>
      <url>/2017/06/15/mybatis-6/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_5]]></title>
      <url>/2017/06/15/mybatis-5/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_4]]></title>
      <url>/2017/06/15/mybatis-4/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_3]]></title>
      <url>/2017/06/15/mybatis-3/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_2]]></title>
      <url>/2017/06/15/mybatis-2/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SqlSessionFactoryBuilder]]></title>
      <url>/2017/06/15/mybatis-1/</url>
      <content type="html"><![CDATA[<p>　　SqlSessionFactoryBuilder是MyBatis的执行入口，使用MyBatis首先要构建一个SqlSessionFactory容器，SqlSessionFactoryBuilder就是构建SqlSessionFactory的创建者。<br>　　以下是SqlSessionFactoryBuilder的OutLine：<br><img src="/images/mybatis_4.png" alt=""></p>
<p>实际执行的build只有三个:</p>
<ul>
<li>build(InputStream inputStream, String environment, Properties properties)</li>
<li>build(Reader reader, String environment, Properties properties)</li>
<li>build(Configuration config)</li>
</ul>
<p>　　前两种的区别只有使用字符流还是字节流，本质上都是通过读取MyBatis的配置文件来进行初始化工作。其中environment可以指定使用的数据源，需要使用多个库的时候会用到这个参数，需要注意的是每个SqlSessionFactory只能对应一个数据源。properties参数可以定义额外的配置参数，与properties文件中配置的功能相同。而第三种是以编程的方式对MyBatis容器进行初始化。（注：前两种最后还是会调用第三种方法）</p>
<p>下面取第一个build的源码进行示例：</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}
</code></pre><p>由上面代码一看可知，初始化配置的关键在于XMLConfigBuilder这个解析类的parse()，parse()方法对MyBatis的一系列标签进行归类注册，创建容器实例，具体代码如下：</p>
<pre><code>private void parseConfiguration(XNode root) {
    try {
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre><p>　　值得注意的是properties和environments，这两个在XMLConfigBuilder的构造方法中是可以当做参数传入的，其中properties会在初始化properties标签时将参数中的properties添加到对应集合中，而environments如果不为空，则会使用id为environments对应值的数据源，否则会使用默认的数据源。其余每个方法对应的都是MyBatis配置文件中的一种标签，具体内容可以在MyBatis的官方文档查询，此处不再赘述。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis架构设计总结]]></title>
      <url>/2017/06/14/mybatis/</url>
      <content type="html"><![CDATA[<h1 id="一-MyBatis的架构"><a href="#一-MyBatis的架构" class="headerlink" title="一. MyBatis的架构"></a>一. MyBatis的架构</h1><p><img src="/images/mybatis_1.png" alt=""></p>
<a id="more"></a>
<h2 id="1-接口层"><a href="#1-接口层" class="headerlink" title="1.接口层"></a>1.接口层</h2><p>接口层提供了与数据库交互的入口，MyBatis支持两种方式的接口调用</p>
<ul>
<li>传统API方式</li>
<li>mapper接口方式</li>
</ul>
<h3 id="1-1-传统API"><a href="#1-1-传统API" class="headerlink" title="1.1. 传统API"></a>1.1. 传统API</h3><p><img src="/images/mybatis_2.png" alt=""><br>　　例：int i = session.selectOne(“daoMapper.UserMapper.selectIDByUser”, u);<br>　　传统API的方式虽然很简洁，但是并不方便，不仅要根据sql类型手动选择调用的方法，而且StatementID使用字符串形式的拼写也加大了人为错误的因素，并不符合框架避免人为错误的这一个特点。</p>
<h2 id="1-2-Mapper接口"><a href="#1-2-Mapper接口" class="headerlink" title="1.2. Mapper接口"></a>1.2. Mapper接口</h2><p>　　MyBatis支持两种Mapper接口的实现形式一种是java注解，一种是xml配置。</p>
<h3 id="1-2-1-注解"><a href="#1-2-1-注解" class="headerlink" title="1.2.1. 注解"></a>1.2.1. 注解</h3><pre><code>@Select(&quot;select id from users where phoneNO = #{phoneNO}&quot;)
public int selectID(String phoneNO);
</code></pre><p>注解形式开发比较简单，但是不适合比较复杂的sql。</p>
<h3 id="1-2-2-xml配置"><a href="#1-2-2-xml配置" class="headerlink" title="1.2.2. xml配置"></a>1.2.2. xml配置</h3><pre><code>mapper.java:
public User selectUser(Integer id);

mapper.xml:
&lt;select id=&quot;selectUser&quot; resultType=&quot;dao.User&quot; &gt;
  select * from policy where id=#{id}
 &lt;/select&gt;
</code></pre><p>　　xml配置自由度更大，而且支持动态拼接sql，可以根据传入参数. 条件等决定最终生成的sql对象。<br>　　Mapper接口的调用入口是Configuration.getMapper，MyBatis在初始化运行环境上下文（Configuration）时会读取配置的mapper文件，为mapper中配置的xml文件生成对应的statement，在调用mapper中的方法时，MyBatis会根据方法名和mapper名确定一个唯一的StatementID，值得注意的是mapper形式其实也是调用传统API进行操作的。</p>
<h2 id="2-数据处理层"><a href="#2-数据处理层" class="headerlink" title="2.数据处理层"></a>2.数据处理层</h2><p>数据处理层可以说是MyBatis的核心精华所在，主要包括以下三个功能：</p>
<ul>
<li>处理参数生成动态SQL</li>
<li>数据库操作</li>
<li>处理结果集</li>
</ul>
<h3 id="2-1-处理参数生成动态SQL"><a href="#2-1-处理参数生成动态SQL" class="headerlink" title="2.1. 处理参数生成动态SQL"></a>2.1. 处理参数生成动态SQL</h3><p>　　动态生成SQL是一个很优雅的设计，MyBatis通过请求传入的参数对象和Ognl表达式来动态生成需要执行的sql语句，这使得设计sql的时候有很强的灵活性和扩展性。处理参数这部分主要分为两步，首先是查询的时候通过preparedStatement将参数对象与jdbc类型进行映射，其次是查询出结果集时，通过resultSet将查询结果与java类型进行映射。</p>
<h3 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2. 数据库操作"></a>2.2. 数据库操作</h3><p>　　MyBatis底层与数据库的交互依然是使用的JDBC实现，主要通过Executor这个执行者协调各个模块完成请求操作。</p>
<h3 id="2-3-处理结果集"><a href="#2-3-处理结果集" class="headerlink" title="2.3. 处理结果集"></a>2.3. 处理结果集</h3><p>　　MyBatis会将数据库返回的结果映射为List<e>的形式，这里要提到ResultMap，这个标签的功能很强大，可以完成多层多类型嵌套，支持多对一或一对多的数据形式。下面是一个例子：</e></p>
<pre><code>&lt;resultMap type=&quot;com.ymt.config.protectplan.domain.dto.ProtectplanDto&quot; id=&quot;protectplanDetail&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;protectPlanID&quot;/&gt;
    &lt;result property=&quot;protectPlanName&quot; column=&quot;protectPlanName&quot;/&gt;
    &lt;result property=&quot;protectPlanDesc&quot; column=&quot;protectPlanDesc&quot;/&gt;
    &lt;result property=&quot;protectplanStatus&quot; column=&quot;protectplanStatus&quot;/&gt;
    &lt;result property=&quot;createTime&quot; column=&quot;protectPlanCreateTime&quot;/&gt;
    &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanLastUpdate&quot;/&gt;
    &lt;collection property=&quot;detailList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;protectPlanContentID&quot;/&gt;
        &lt;result property=&quot;protectPlanContName&quot; column=&quot;protectPlanContName&quot;/&gt;
        &lt;result property=&quot;protectPlanID&quot; column=&quot;protectPlanID&quot;/&gt;
        &lt;result property=&quot;protectPlanContentType&quot; column=&quot;protectPlanContentType&quot;/&gt;
        &lt;result property=&quot;priority&quot; column=&quot;priority&quot;/&gt;
        &lt;result property=&quot;createTime&quot; column=&quot;protectPlanContentCreateTime&quot;/&gt;
        &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanContentLastUpdate&quot;/&gt;
        &lt;collection property=&quot;insuranceList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
            &lt;id property=&quot;kindID&quot; column=&quot;kindID&quot;/&gt;
            &lt;result property=&quot;hasFree&quot; column=&quot;hasFree&quot;/&gt;
            &lt;result property=&quot;isFree&quot; column=&quot;isFree&quot;/&gt;
            &lt;result property=&quot;mainFlag&quot; column=&quot;mainFlag&quot;/&gt;
            &lt;result property=&quot;amount&quot; column=&quot;detailAmount&quot;/&gt;
            &lt;collection property=&quot;amountList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
                &lt;id  column=&quot;customID&quot;/&gt;
                &lt;result property=&quot;amount&quot; column=&quot;amount&quot;/&gt;
                &lt;result property=&quot;amountShow&quot; column=&quot;amountShow&quot;/&gt;
                &lt;result property=&quot;isDefault&quot; column=&quot;isDefault&quot;/&gt;
            &lt;/collection&gt;
        &lt;/collection&gt;    
    &lt;/collection&gt;
&lt;/resultMap&gt;        
</code></pre><h2 id="3-支撑服务层"><a href="#3-支撑服务层" class="headerlink" title="3. 支撑服务层"></a>3. 支撑服务层</h2><p>　　支撑服务层主要为数据处理层提供额外功能。</p>
<h3 id="3-1-元对象模块"><a href="#3-1-元对象模块" class="headerlink" title="3.1. 元对象模块"></a>3.1. 元对象模块</h3><p>　　元对象是MyBatis的一个独立的模块，提供了一种简洁而优雅的访问对象的方式，使得开发时只需要专注于具体的业务，而不需要关注反射细节，并且无需手动处理各种反射异常。其具体实现是依赖与java的反射机制，所以嘛性能是有点损耗的，不过比起方便程度来说也是可以接受的。（不依赖其他模块，可以单独提出使用）</p>
<h3 id="3-2-缓存机制"><a href="#3-2-缓存机制" class="headerlink" title="3.2. 缓存机制"></a>3.2. 缓存机制</h3><p>　　在越来越高的并发量的冲击下，不论是服务器还是数据库的压力都越来越大，缓存机制就是缓解数据库这方面的访问压力的。MyBatis设置了两个缓存层级，一级缓存存在于一次SqlSession会话内，一次会话可以不必重复查询相同的数据，二级缓存可以跨SqlSession存在，但是有很大风险。总之，使用MyBatis的缓存要谨慎，不然反而会影响程序的时效性。</p>
<h3 id="3-3-拦截器机制"><a href="#3-3-拦截器机制" class="headerlink" title="3.3. 拦截器机制"></a>3.3. 拦截器机制</h3><p>　　拦截器是MyBatis提供的一种可以改变自身运行机制的方式，拦截器仅支持拦截Executor. StatementHandler. ResultSetHandler. ParameterHandler。可以对MyBatis做一些定制化的修改，比如常用的分页，分库分表，读写分离，分类缓存等。</p>
<h3 id="3-4-事务管理"><a href="#3-4-事务管理" class="headerlink" title="3.4. 事务管理"></a>3.4. 事务管理</h3><p>　　事务管理是ORM框架的一个必不可少的部分。</p>
<h3 id="3-5-连接池机制"><a href="#3-5-连接池机制" class="headerlink" title="3.5. 连接池机制"></a>3.5. 连接池机制</h3><p>　　创建数据库连接占据了一次会话的大部分时间，所以在访问量大的系统中，连接池就至关重要，连接池维护了所有数据库会话，节省了每次创建连接的性能开销。</p>
<h3 id="3-6-Sql的配置方式"><a href="#3-6-Sql的配置方式" class="headerlink" title="3.6. Sql的配置方式"></a>3.6. Sql的配置方式</h3><p>　　MyBatis的传统配置方式是基于xml配置，但是面向接口编程之风越来越盛，而且xml配置也很繁琐，并不适合简单sql，所以就诞生了一种符合面向接口编程思想的方式，而接口调用就引申出了注解这个大杀器，从此以后就可以使用mapper接口+注解的方式来配置sql，但是需要注意的是MyBatis对注解的支持还很简单，很多复杂的功能还是要用xml配置的。</p>
<h1 id="二-MyBatis的主要模块"><a href="#二-MyBatis的主要模块" class="headerlink" title="二. MyBatis的主要模块"></a>二. MyBatis的主要模块</h1><ul>
<li>SqlSession：数据库会话模块，MyBatis的顶层API，程序的调用入口。</li>
<li>Configuration：运行环境上下文，维护了MyBatis的所有配置信息，以及各种缓存区。</li>
<li>Executor：MyBatis的执行器，负责调度数据库操作的整个流程，完成各种缓存相关操作。</li>
<li>StatementHandler：封装了JDBC的Statement操作，包括设置参数，转换结果为List等。</li>
<li>ResultSetHandler：负责将结果集与java类型进行映射，转换为指定的类型。</li>
<li>ParameterHandler：负责处理参数对象，将参数与jdbc类型进行映射。</li>
<li>TypeHandle：类型处理器，主要负责jdbc与java的类型转换。</li>
<li>MapperStatement：维护了CRUD节点的信息。</li>
<li>SQLSource：根据传递的参数对象动态生成sql语句，并封装为BoundSql对象。</li>
<li>BoundSql：封装了sql相关的参数信息。</li>
<li>Plugin：拦截器组件，可以在一定程度上定制MyBatis的执行流程。</li>
<li>MetaObject：元对象模块，简洁而优雅的反射工具。</li>
</ul>
<p>(MyBatis只有这几个模块吗？当然不是，那为什么只写这几个是重点呢？这个嘛，当然是我只看了这几个模块的源码了=。=)<br><img src="/images/mybatis_3.png" alt=""></p>
<h1 id="三-MyBatis执行流程"><a href="#三-MyBatis执行流程" class="headerlink" title="三. MyBatis执行流程"></a>三. MyBatis执行流程</h1><p>此处由MyBatis的查询操作举例</p>
<h2 id="1-开启SqlSession"><a href="#1-开启SqlSession" class="headerlink" title="1. 开启SqlSession"></a>1. 开启SqlSession</h2><pre><code>InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,&quot;development1&quot;);
SqlSession session = sqlSessionFactory.openSession();
MyBatis的数据库会话封装在SqlSession中，SqlSession作为顶层API，肩负着增删改查的调度任务。
</code></pre><h2 id="2-SqlSession的查询"><a href="#2-SqlSession的查询" class="headerlink" title="2. SqlSession的查询"></a>2. SqlSession的查询</h2><pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //在configuration中维护了一个Map&lt;String, MappedStatement&gt;集合，在初始化的时候会读取所有sql配置文件中的信息，
      //每个sql会生成一个对应的上下文MappedStatement，缓存在这个集合中。
      MappedStatement ms = configuration.getMappedStatement(statement);
      //具体操作下放至Executor执行
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
</code></pre><p>　　在MyBatis初始化时，会根据加载的配置文件创建Configuration实例，mapper配置文件中的sql会生成对应的MappedStatement实例，Configuration维护了一个Map集合来缓存MappedStatement实例，key为nameSpace.functionName。<br>　　SqlSession会根据传入的statementID（即上面的key）获取配置缓存区中的MappedStatement实例，然后将操作参数交给Executor执行具体任务。</p>
<h2 id="3-Executor执行器"><a href="#3-Executor执行器" class="headerlink" title="3. Executor执行器"></a>3. Executor执行器</h2><h3 id="3-1-BaseExecutor"><a href="#3-1-BaseExecutor" class="headerlink" title="3.1. BaseExecutor"></a>3.1. BaseExecutor</h3><pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    //创建BoundSql实例
    BoundSql boundSql = ms.getBoundSql(parameter);
    //获取缓存key
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    //如果已经关闭则抛出异常
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //当查询堆栈为0且flushCacheRequired配置为true则刷新一级缓存区
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
      queryStack++;
      //根据参数中的resultHandler来判断是否从一级缓存中获取结果集，selectList方法传入的resultHandler默认为null
      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
      if (list != null) {//缓存中存在结果集时
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        //从数据库获取数据
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    //当查询堆栈为0时加载延迟加载列表中的所有元素
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      //清空延迟加载列表
      deferredLoads.clear();
      //如果设置的本地缓存等级为statement，则清空一级缓存
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache();
      }
    }
    return list;
  }
private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&lt;E&gt; list;
    //执行查询前用占位符在一级缓存中占位
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //具体查询方法，由子类进行差异化实现
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //将结果集放入一级缓存中
    localCache.putObject(key, list);
    //如果statement的类型为CALLABLE，在localOutputParameterCache中放入参数
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
</code></pre><p>BaseExecutor作为模板类，主要任务就是创建BoundSql实例. 处理一级缓存的内容，以及决定是否需要重新查询数据库取值，具体的数据库操作doQuery由子类进行差异化实现。</p>
<h3 id="3-2-SimpleExecutor"><a href="#3-2-SimpleExecutor" class="headerlink" title="3.2. SimpleExecutor"></a>3.2. SimpleExecutor</h3><pre><code>public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      //获取配置上下文
      Configuration configuration = ms.getConfiguration();
      //创建StatementHandler实例
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //创建statement实例，具体生成过程会放在StatementHandler模块讲解
      stmt = prepareStatement(handler, ms.getStatementLog());
      //具体执行操作
      return handler.&lt;E&gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
</code></pre><p>　　这里可以看出Executor的主要任务就是通过StatementHandler创建Statement实例，此时会将参数绑定到statement的指定位置，然后将任务下方到StatementHandler中，StatementHandler与JDBC进行交互。</p>
<h2 id="4-SimpleStatementHandler"><a href="#4-SimpleStatementHandler" class="headerlink" title="4. SimpleStatementHandler"></a>4. SimpleStatementHandler</h2><pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行查询
    statement.execute(sql);
    //处理结果集
    return resultSetHandler.&lt;E&gt;handleResultSets(statement);
  }
</code></pre><p>　　SimpleStatementHandler执行了sql语句，并将结果交给ResultSetHandler处理。</p>
<h2 id="5-ResultSetHandler"><a href="#5-ResultSetHandler" class="headerlink" title="5. ResultSetHandler"></a>5. ResultSetHandler</h2><pre><code>public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

    //已处理结果行数
    int resultSetCount = 0;
    //ResultSetWrapper是ResultSet的包装类
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    //获取结果集
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    //判断是否有结果集，没有则抛出异常
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      //映射结果集
      handleResultSet(rsw, resultMap, multipleResults, null);
      //如果有多个结果集时，此处rsw不为null
      rsw = getNextResultSet(stmt);
      //清空缓存池
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResultSets();
    if (resultSets != null) {
      //当存在多个结果集时执行以下逻辑
      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          //获取嵌套结果集id
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          //从一级缓存中获取结果集
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          //绑定子结果集，此处的parentMapping为父级结果集
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        //获取下一个结果集
        rsw = getNextResultSet(stmt);
        //清空缓存池
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
</code></pre><p>　　ResultSetHandler会将查询结果转换为List<e>的形式，如果调用的是selectOne方法，则会取List中的第一条数据返回，如果List为空会抛出异常。</e></p>
<p>上述只是简单描述了MyBatis的查询流程，其实具体细节有很多，无法一一列举，详细内容之后会单独在各个模块的源码讲解中详述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[mybatis_13]]></title>
      <url>/2017/06/15/mybatis-13/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_12]]></title>
      <url>/2017/06/15/mybatis-12/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_11]]></title>
      <url>/2017/06/15/mybatis-11/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_10]]></title>
      <url>/2017/06/15/mybatis-10/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_9]]></title>
      <url>/2017/06/15/mybatis-9/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_8]]></title>
      <url>/2017/06/15/mybatis-8/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_7]]></title>
      <url>/2017/06/15/mybatis-7/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_6]]></title>
      <url>/2017/06/15/mybatis-6/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_5]]></title>
      <url>/2017/06/15/mybatis-5/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis_4]]></title>
      <url>/2017/06/15/mybatis-4/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：SqlSession]]></title>
      <url>/2017/06/15/mybatis-3/</url>
      <content type="html"><![CDATA[<p>　　顾名思义SqlSession指的就是数据库会话，之前说过SqlSessionFactory如何生成SqlSession实例，本次不在赘述。</p>
<p>　　session中包含了两种执行sql的形式，一种是传统的CRUD，另一种是mapper形式。官方文档推荐使用mapper形式，理由是代码更优雅（笑）。其实主要是mapper形式更加简易，而且通过接口+xml的开发模式代码耦合性很低，更符合开闭原则，而且逻辑看起来更加清晰，配合MyBatis的异常系统定位异常位置简单粗暴（笑哭）。先看下传统的调用方式，下面是outline图：<br><img src="/images/mybatis_6.png" alt=""><br><a id="more"></a><br>　　这么多方法自然不能一一说明，此处仅取selectList方法进行示例说明：</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
   try {
     //在configuration中维护了一个Map&lt;String, MappedStatement&gt;集合，在初始化的时候会读取所有sql配置文件中的信息，
     //每个sql会生成一个对应的上下文MappedStatement，缓存在这个集合中。
     MappedStatement ms = configuration.getMappedStatement(statement);
     //具体操作下放至Executor执行
     return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
   } catch (Exception e) {
     throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
   } finally {
     ErrorContext.instance().reset();
   }
 }
</code></pre><p>　　源码里写的很简练，第一步获取初始化时创建的sql的对应上下文对象，第二部将具体操作下放到Executor中执行。这里就体现出来SqlSession和Executor的职务差别，SqlSession只负责构造一个sql操作的执行环境，Executor只负责对数据库操作，分工明确。</p>
<p>下面看一下mapper形式是如何执行sql操作的：</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
   return configuration.&lt;T&gt;getMapper(type, this);
 }
</code></pre><p>很简单，直接甩锅给configuration（笑），而configuration里又有一个MapperRegistry对象，这个对象可是很关键，MapperRegistry在初始化时会缓存所有mapper接口的反射工厂实例，下面看两个关键的方法：</p>
<pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
    //mapper类限定只能是接口
    if (type.isInterface()) {
      //初始化上下文时会注册所有已检索的mapper接口，所以通常不会出现这个异常，除非配置有问题
      if (hasMapper(type)) {
        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);
      }
      //用于finally中校验已注册的mapper对象是否是完整对象，如果对象信息不完整则从缓存中删除
      boolean loadCompleted = false;
      try {
        //knownMappers是一个Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;集合，
        //此处实例化一个mapper接口对应的MapperProxyFactory放入集合中，供之后实例化时调用。
        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        //此处会生成对应的MappedStatement，并且放入Configuration的缓存集合mappedStatements中
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    //首先获取mapper代理工厂实例
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      //通过工厂实例创建mapper的代理实例
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
  }
</code></pre><p>此处可以看到有一个关键的类MapperProxyFactory，顾名思义这是个mapper代理工厂类，而实际的代理类是MapperProxy，下面看一下MapperProxy的invoke方法：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   try {
     //如果代理的是object类，则直接调用被代理方法
     if (Object.class.equals(method.getDeclaringClass())) {
       return method.invoke(this, args);
     } else if (isDefaultMethod(method)) {
       //如果代理执行的方法是接口的默认实现方法（jdk1.8中加入），则创建一个接口实例，执行此方法
       return invokeDefaultMethod(proxy, method, args);
     }
   } catch (Throwable t) {
     throw ExceptionUtil.unwrapThrowable(t);
   }
   //如果执行的方法是属于已注册mapper接口的抽象方法，则执行下面方法。先在methodCache缓存中获取MapperRegistry注册mapper接口时生成
   //在MapperRegistry注册mapper接口时会创建一个接口方法实例缓存池methodCache，每次执行接口代理方法时会查询缓存池中是否包含此方法的实例，
   //如果不存在，则创建对应方法实例放入缓存，并执行代理方法。
   final MapperMethod mapperMethod = cachedMapperMethod(method);
   return mapperMethod.execute(sqlSession, args);
 }
</code></pre><p>这个MapperMethod是MyBatis中的sql操作方法类，暴露给外部调用的也只有execute(SqlSession sqlSession, Object[] args)方法而已，下面看下这个方法的代码：</p>
<pre><code>public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    //根据sql类型判断执行的方法
    switch (command.getType()) {
      case INSERT: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      case UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        break;
      }
      case DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        break;
      }
      case SELECT:
        if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } else if (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } else if (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } else {
          Object param = method.convertArgsToSqlCommandParam(args);
          result = sqlSession.selectOne(command.getName(), param);
        }
        break;
      case FLUSH:
        result = sqlSession.flushStatements();
        break;
      default:
        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
      throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() 
          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    return result;
  }
</code></pre><p>由上可见，其实mapper形式写法最终还是调用SqlSession中的一系列方法，这么看来MyBatis官方文档中说的使用mapper看起来更优雅还真是实至名归（笑）</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/06/15/mybatis-2/</url>
      <content type="html"><![CDATA[<hr>
<p>title: MyBatis源码解析：SqlSessionFactory<br>date: 2017-06-15 15:16:31<br>tags: MyBatis<br>—　</p>
<p>　　使用MyBatis框架时，首先要使用SqlSessionFactoryBuilder.build方法来实例化一个SqlSessionFactory，SqlSessionFactory相当于一个数据库连接工厂。<br>SqlSessionFactory接口定义了生成SqlSession实例的几种两种方式，MyBatis中有两个默认实现DefaultSqlSessionFactory和SqlSessionManager。SqlSessionManager貌似已经废弃，此处不再写。<br><a id="more"></a><br>　　DefaultSqlSessionFactory内部维护了一个Configuration实例，Configuration中的配置属性是生成SqlSession实例的关键。下面是DefaultSqlSessionFactory的OutLine图：<br><img src="/images/mybatis_5.png" alt=""></p>
<p>看似很多种重载方法，但是实际执行的只有两个</p>
<ul>
<li>openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit)</li>
<li>openSessionFromConnection(ExecutorType execType, Connection connection)</li>
</ul>
<p>　　这两个方法的区别就在于是从Configuration中获取事务管理器工厂创建事务管理器，还是从Connection中获取事务管理器。下面取第一个方法做示例：</p>
<pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;
  try {
    //获取数据源对象
    final Environment environment = configuration.getEnvironment();
    //获取事务工厂，如果数据源不存在或者数据源中没有实例化事务工厂，则创建ManagedTransactionFactory实例作为事务工厂使用
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    //实例化事务控制器
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    //实例化Executor执行器
    final Executor executor = configuration.newExecutor(tx, execType);
    //实例化SqlSession
    return new DefaultSqlSession(configuration, executor, autoCommit);
  } catch (Exception e) {
    closeTransaction(tx); // may have fetched a connection so lets call close()
    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}　
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码解析：SqlSessionFactoryBuilder]]></title>
      <url>/2017/06/15/mybatis-1/</url>
      <content type="html"><![CDATA[<p>　　SqlSessionFactoryBuilder是MyBatis的执行入口，使用MyBatis首先要构建一个SqlSessionFactory容器，SqlSessionFactoryBuilder就是构建SqlSessionFactory的创建者。<br>　　以下是SqlSessionFactoryBuilder的OutLine：<br><img src="/images/mybatis_4.png" alt=""><br><a id="more"></a><br>实际执行的build只有三个:</p>
<ul>
<li>build(InputStream inputStream, String environment, Properties properties)</li>
<li>build(Reader reader, String environment, Properties properties)</li>
<li>build(Configuration config)</li>
</ul>
<p>　　前两种的区别只有使用字符流还是字节流，本质上都是通过读取MyBatis的配置文件来进行初始化工作。其中environment可以指定使用的数据源，需要使用多个库的时候会用到这个参数，需要注意的是每个SqlSessionFactory只能对应一个数据源。properties参数可以定义额外的配置参数，与properties文件中配置的功能相同。而第三种是以编程的方式对MyBatis容器进行初始化。（注：前两种最后还是会调用第三种方法）</p>
<p>下面取第一个build的源码进行示例：</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}
</code></pre><p>由上面代码一看可知，初始化配置的关键在于XMLConfigBuilder这个解析类的parse()，parse()方法对MyBatis的一系列标签进行归类注册，创建容器实例，具体代码如下：</p>
<pre><code>private void parseConfiguration(XNode root) {
    try {
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre><p>　　值得注意的是properties和environments，这两个在XMLConfigBuilder的构造方法中是可以当做参数传入的，其中properties会在初始化properties标签时将参数中的properties添加到对应集合中，而environments如果不为空，则会使用id为environments对应值的数据源，否则会使用默认的数据源。其余每个方法对应的都是MyBatis配置文件中的一种标签，具体内容可以在MyBatis的官方文档查询，此处不再赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis架构设计总结]]></title>
      <url>/2017/06/14/mybatis/</url>
      <content type="html"><![CDATA[<h1 id="一-MyBatis的架构"><a href="#一-MyBatis的架构" class="headerlink" title="一. MyBatis的架构"></a>一. MyBatis的架构</h1><p><img src="/images/mybatis_1.png" alt=""></p>
<a id="more"></a>
<h2 id="1-接口层"><a href="#1-接口层" class="headerlink" title="1.接口层"></a>1.接口层</h2><p>接口层提供了与数据库交互的入口，MyBatis支持两种方式的接口调用</p>
<ul>
<li>传统API方式</li>
<li>mapper接口方式</li>
</ul>
<h3 id="1-1-传统API"><a href="#1-1-传统API" class="headerlink" title="1.1. 传统API"></a>1.1. 传统API</h3><p><img src="/images/mybatis_2.png" alt=""><br>　　例：int i = session.selectOne(“daoMapper.UserMapper.selectIDByUser”, u);<br>　　传统API的方式虽然很简洁，但是并不方便，不仅要根据sql类型手动选择调用的方法，而且StatementID使用字符串形式的拼写也加大了人为错误的因素，并不符合框架避免人为错误的这一个特点。</p>
<h2 id="1-2-Mapper接口"><a href="#1-2-Mapper接口" class="headerlink" title="1.2. Mapper接口"></a>1.2. Mapper接口</h2><p>　　MyBatis支持两种Mapper接口的实现形式一种是java注解，一种是xml配置。</p>
<h3 id="1-2-1-注解"><a href="#1-2-1-注解" class="headerlink" title="1.2.1. 注解"></a>1.2.1. 注解</h3><pre><code>@Select(&quot;select id from users where phoneNO = #{phoneNO}&quot;)
public int selectID(String phoneNO);
</code></pre><p>注解形式开发比较简单，但是不适合比较复杂的sql。</p>
<h3 id="1-2-2-xml配置"><a href="#1-2-2-xml配置" class="headerlink" title="1.2.2. xml配置"></a>1.2.2. xml配置</h3><pre><code>mapper.java:
public User selectUser(Integer id);

mapper.xml:
&lt;select id=&quot;selectUser&quot; resultType=&quot;dao.User&quot; &gt;
  select * from policy where id=#{id}
 &lt;/select&gt;
</code></pre><p>　　xml配置自由度更大，而且支持动态拼接sql，可以根据传入参数. 条件等决定最终生成的sql对象。<br>　　Mapper接口的调用入口是Configuration.getMapper，MyBatis在初始化运行环境上下文（Configuration）时会读取配置的mapper文件，为mapper中配置的xml文件生成对应的statement，在调用mapper中的方法时，MyBatis会根据方法名和mapper名确定一个唯一的StatementID，值得注意的是mapper形式其实也是调用传统API进行操作的。</p>
<h2 id="2-数据处理层"><a href="#2-数据处理层" class="headerlink" title="2.数据处理层"></a>2.数据处理层</h2><p>数据处理层可以说是MyBatis的核心精华所在，主要包括以下三个功能：</p>
<ul>
<li>处理参数生成动态SQL</li>
<li>数据库操作</li>
<li>处理结果集</li>
</ul>
<h3 id="2-1-处理参数生成动态SQL"><a href="#2-1-处理参数生成动态SQL" class="headerlink" title="2.1. 处理参数生成动态SQL"></a>2.1. 处理参数生成动态SQL</h3><p>　　动态生成SQL是一个很优雅的设计，MyBatis通过请求传入的参数对象和Ognl表达式来动态生成需要执行的sql语句，这使得设计sql的时候有很强的灵活性和扩展性。处理参数这部分主要分为两步，首先是查询的时候通过preparedStatement将参数对象与jdbc类型进行映射，其次是查询出结果集时，通过resultSet将查询结果与java类型进行映射。</p>
<h3 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2. 数据库操作"></a>2.2. 数据库操作</h3><p>　　MyBatis底层与数据库的交互依然是使用的JDBC实现，主要通过Executor这个执行者协调各个模块完成请求操作。</p>
<h3 id="2-3-处理结果集"><a href="#2-3-处理结果集" class="headerlink" title="2.3. 处理结果集"></a>2.3. 处理结果集</h3><p>　　MyBatis会将数据库返回的结果映射为List<e>的形式，这里要提到ResultMap，这个标签的功能很强大，可以完成多层多类型嵌套，支持多对一或一对多的数据形式。下面是一个例子：</e></p>
<pre><code>&lt;resultMap type=&quot;com.ymt.config.protectplan.domain.dto.ProtectplanDto&quot; id=&quot;protectplanDetail&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;protectPlanID&quot;/&gt;
    &lt;result property=&quot;protectPlanName&quot; column=&quot;protectPlanName&quot;/&gt;
    &lt;result property=&quot;protectPlanDesc&quot; column=&quot;protectPlanDesc&quot;/&gt;
    &lt;result property=&quot;protectplanStatus&quot; column=&quot;protectplanStatus&quot;/&gt;
    &lt;result property=&quot;createTime&quot; column=&quot;protectPlanCreateTime&quot;/&gt;
    &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanLastUpdate&quot;/&gt;
    &lt;collection property=&quot;detailList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;protectPlanContentID&quot;/&gt;
        &lt;result property=&quot;protectPlanContName&quot; column=&quot;protectPlanContName&quot;/&gt;
        &lt;result property=&quot;protectPlanID&quot; column=&quot;protectPlanID&quot;/&gt;
        &lt;result property=&quot;protectPlanContentType&quot; column=&quot;protectPlanContentType&quot;/&gt;
        &lt;result property=&quot;priority&quot; column=&quot;priority&quot;/&gt;
        &lt;result property=&quot;createTime&quot; column=&quot;protectPlanContentCreateTime&quot;/&gt;
        &lt;result property=&quot;lastUpdate&quot; column=&quot;protectPlanContentLastUpdate&quot;/&gt;
        &lt;collection property=&quot;insuranceList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
            &lt;id property=&quot;kindID&quot; column=&quot;kindID&quot;/&gt;
            &lt;result property=&quot;hasFree&quot; column=&quot;hasFree&quot;/&gt;
            &lt;result property=&quot;isFree&quot; column=&quot;isFree&quot;/&gt;
            &lt;result property=&quot;mainFlag&quot; column=&quot;mainFlag&quot;/&gt;
            &lt;result property=&quot;amount&quot; column=&quot;detailAmount&quot;/&gt;
            &lt;collection property=&quot;amountList&quot; ofType=&quot;java.util.Map&quot; javaType=&quot;java.util.ArrayList&quot;&gt;
                &lt;id  column=&quot;customID&quot;/&gt;
                &lt;result property=&quot;amount&quot; column=&quot;amount&quot;/&gt;
                &lt;result property=&quot;amountShow&quot; column=&quot;amountShow&quot;/&gt;
                &lt;result property=&quot;isDefault&quot; column=&quot;isDefault&quot;/&gt;
            &lt;/collection&gt;
        &lt;/collection&gt;    
    &lt;/collection&gt;
&lt;/resultMap&gt;        
</code></pre><h2 id="3-支撑服务层"><a href="#3-支撑服务层" class="headerlink" title="3. 支撑服务层"></a>3. 支撑服务层</h2><p>　　支撑服务层主要为数据处理层提供额外功能。</p>
<h3 id="3-1-元对象模块"><a href="#3-1-元对象模块" class="headerlink" title="3.1. 元对象模块"></a>3.1. 元对象模块</h3><p>　　元对象是MyBatis的一个独立的模块，提供了一种简洁而优雅的访问对象的方式，使得开发时只需要专注于具体的业务，而不需要关注反射细节，并且无需手动处理各种反射异常。其具体实现是依赖与java的反射机制，所以嘛性能是有点损耗的，不过比起方便程度来说也是可以接受的。（不依赖其他模块，可以单独提出使用）</p>
<h3 id="3-2-缓存机制"><a href="#3-2-缓存机制" class="headerlink" title="3.2. 缓存机制"></a>3.2. 缓存机制</h3><p>　　在越来越高的并发量的冲击下，不论是服务器还是数据库的压力都越来越大，缓存机制就是缓解数据库这方面的访问压力的。MyBatis设置了两个缓存层级，一级缓存存在于一次SqlSession会话内，一次会话可以不必重复查询相同的数据，二级缓存可以跨SqlSession存在，但是有很大风险。总之，使用MyBatis的缓存要谨慎，不然反而会影响程序的时效性。</p>
<h3 id="3-3-拦截器机制"><a href="#3-3-拦截器机制" class="headerlink" title="3.3. 拦截器机制"></a>3.3. 拦截器机制</h3><p>　　拦截器是MyBatis提供的一种可以改变自身运行机制的方式，拦截器仅支持拦截Executor. StatementHandler. ResultSetHandler. ParameterHandler。可以对MyBatis做一些定制化的修改，比如常用的分页，分库分表，读写分离，分类缓存等。</p>
<h3 id="3-4-事务管理"><a href="#3-4-事务管理" class="headerlink" title="3.4. 事务管理"></a>3.4. 事务管理</h3><p>　　事务管理是ORM框架的一个必不可少的部分。</p>
<h3 id="3-5-连接池机制"><a href="#3-5-连接池机制" class="headerlink" title="3.5. 连接池机制"></a>3.5. 连接池机制</h3><p>　　创建数据库连接占据了一次会话的大部分时间，所以在访问量大的系统中，连接池就至关重要，连接池维护了所有数据库会话，节省了每次创建连接的性能开销。</p>
<h3 id="3-6-Sql的配置方式"><a href="#3-6-Sql的配置方式" class="headerlink" title="3.6. Sql的配置方式"></a>3.6. Sql的配置方式</h3><p>　　MyBatis的传统配置方式是基于xml配置，但是面向接口编程之风越来越盛，而且xml配置也很繁琐，并不适合简单sql，所以就诞生了一种符合面向接口编程思想的方式，而接口调用就引申出了注解这个大杀器，从此以后就可以使用mapper接口+注解的方式来配置sql，但是需要注意的是MyBatis对注解的支持还很简单，很多复杂的功能还是要用xml配置的。</p>
<h1 id="二-MyBatis的主要模块"><a href="#二-MyBatis的主要模块" class="headerlink" title="二. MyBatis的主要模块"></a>二. MyBatis的主要模块</h1><ul>
<li>SqlSession：数据库会话模块，MyBatis的顶层API，程序的调用入口。</li>
<li>Configuration：运行环境上下文，维护了MyBatis的所有配置信息，以及各种缓存区。</li>
<li>Executor：MyBatis的执行器，负责调度数据库操作的整个流程，完成各种缓存相关操作。</li>
<li>StatementHandler：封装了JDBC的Statement操作，包括设置参数，转换结果为List等。</li>
<li>ResultSetHandler：负责将结果集与java类型进行映射，转换为指定的类型。</li>
<li>ParameterHandler：负责处理参数对象，将参数与jdbc类型进行映射。</li>
<li>TypeHandle：类型处理器，主要负责jdbc与java的类型转换。</li>
<li>MapperStatement：维护了CRUD节点的信息。</li>
<li>SQLSource：根据传递的参数对象动态生成sql语句，并封装为BoundSql对象。</li>
<li>BoundSql：封装了sql相关的参数信息。</li>
<li>Plugin：拦截器组件，可以在一定程度上定制MyBatis的执行流程。</li>
<li>MetaObject：元对象模块，简洁而优雅的反射工具。</li>
</ul>
<p>(MyBatis只有这几个模块吗？当然不是，那为什么只写这几个是重点呢？这个嘛，当然是我只看了这几个模块的源码了=。=)<br><img src="/images/mybatis_3.png" alt=""></p>
<h1 id="三-MyBatis执行流程"><a href="#三-MyBatis执行流程" class="headerlink" title="三. MyBatis执行流程"></a>三. MyBatis执行流程</h1><p>此处由MyBatis的查询操作举例</p>
<h2 id="1-开启SqlSession"><a href="#1-开启SqlSession" class="headerlink" title="1. 开启SqlSession"></a>1. 开启SqlSession</h2><pre><code>InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is,&quot;development1&quot;);
SqlSession session = sqlSessionFactory.openSession();
MyBatis的数据库会话封装在SqlSession中，SqlSession作为顶层API，肩负着增删改查的调度任务。
</code></pre><h2 id="2-SqlSession的查询"><a href="#2-SqlSession的查询" class="headerlink" title="2. SqlSession的查询"></a>2. SqlSession的查询</h2><pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //在configuration中维护了一个Map&lt;String, MappedStatement&gt;集合，在初始化的时候会读取所有sql配置文件中的信息，
      //每个sql会生成一个对应的上下文MappedStatement，缓存在这个集合中。
      MappedStatement ms = configuration.getMappedStatement(statement);
      //具体操作下放至Executor执行
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
</code></pre><p>　　在MyBatis初始化时，会根据加载的配置文件创建Configuration实例，mapper配置文件中的sql会生成对应的MappedStatement实例，Configuration维护了一个Map集合来缓存MappedStatement实例，key为nameSpace.functionName。<br>　　SqlSession会根据传入的statementID（即上面的key）获取配置缓存区中的MappedStatement实例，然后将操作参数交给Executor执行具体任务。</p>
<h2 id="3-Executor执行器"><a href="#3-Executor执行器" class="headerlink" title="3. Executor执行器"></a>3. Executor执行器</h2><h3 id="3-1-BaseExecutor"><a href="#3-1-BaseExecutor" class="headerlink" title="3.1. BaseExecutor"></a>3.1. BaseExecutor</h3><pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    //创建BoundSql实例
    BoundSql boundSql = ms.getBoundSql(parameter);
    //获取缓存key
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    //如果已经关闭则抛出异常
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //当查询堆栈为0且flushCacheRequired配置为true则刷新一级缓存区
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
      queryStack++;
      //根据参数中的resultHandler来判断是否从一级缓存中获取结果集，selectList方法传入的resultHandler默认为null
      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
      if (list != null) {//缓存中存在结果集时
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        //从数据库获取数据
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    //当查询堆栈为0时加载延迟加载列表中的所有元素
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      //清空延迟加载列表
      deferredLoads.clear();
      //如果设置的本地缓存等级为statement，则清空一级缓存
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache();
      }
    }
    return list;
  }
private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&lt;E&gt; list;
    //执行查询前用占位符在一级缓存中占位
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      //具体查询方法，由子类进行差异化实现
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    //将结果集放入一级缓存中
    localCache.putObject(key, list);
    //如果statement的类型为CALLABLE，在localOutputParameterCache中放入参数
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
</code></pre><p>BaseExecutor作为模板类，主要任务就是创建BoundSql实例. 处理一级缓存的内容，以及决定是否需要重新查询数据库取值，具体的数据库操作doQuery由子类进行差异化实现。</p>
<h3 id="3-2-SimpleExecutor"><a href="#3-2-SimpleExecutor" class="headerlink" title="3.2. SimpleExecutor"></a>3.2. SimpleExecutor</h3><pre><code>public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      //获取配置上下文
      Configuration configuration = ms.getConfiguration();
      //创建StatementHandler实例
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //创建statement实例，具体生成过程会放在StatementHandler模块讲解
      stmt = prepareStatement(handler, ms.getStatementLog());
      //具体执行操作
      return handler.&lt;E&gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
</code></pre><p>　　这里可以看出Executor的主要任务就是通过StatementHandler创建Statement实例，此时会将参数绑定到statement的指定位置，然后将任务下方到StatementHandler中，StatementHandler与JDBC进行交互。</p>
<h2 id="4-SimpleStatementHandler"><a href="#4-SimpleStatementHandler" class="headerlink" title="4. SimpleStatementHandler"></a>4. SimpleStatementHandler</h2><pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    //获取sql
    String sql = boundSql.getSql();
    //执行查询
    statement.execute(sql);
    //处理结果集
    return resultSetHandler.&lt;E&gt;handleResultSets(statement);
  }
</code></pre><p>　　SimpleStatementHandler执行了sql语句，并将结果交给ResultSetHandler处理。</p>
<h2 id="5-ResultSetHandler"><a href="#5-ResultSetHandler" class="headerlink" title="5. ResultSetHandler"></a>5. ResultSetHandler</h2><pre><code>public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();

    //已处理结果行数
    int resultSetCount = 0;
    //ResultSetWrapper是ResultSet的包装类
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    //获取结果集
    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    //判断是否有结果集，没有则抛出异常
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      //映射结果集
      handleResultSet(rsw, resultMap, multipleResults, null);
      //如果有多个结果集时，此处rsw不为null
      rsw = getNextResultSet(stmt);
      //清空缓存池
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResultSets();
    if (resultSets != null) {
      //当存在多个结果集时执行以下逻辑
      while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          //获取嵌套结果集id
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          //从一级缓存中获取结果集
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          //绑定子结果集，此处的parentMapping为父级结果集
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        //获取下一个结果集
        rsw = getNextResultSet(stmt);
        //清空缓存池
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
</code></pre><p>　　ResultSetHandler会将查询结果转换为List<e>的形式，如果调用的是selectOne方法，则会取List中的第一条数据返回，如果List为空会抛出异常。</e></p>
<p>上述只是简单描述了MyBatis的查询流程，其实具体细节有很多，无法一一列举，详细内容之后会单独在各个模块的源码讲解中详述。</p>
]]></content>
      
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
